<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[惊鸿三世的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.codingplayboy.com/"/>
  <updated>2016-01-06T16:42:16.000Z</updated>
  <id>http://blog.codingplayboy.com/</id>
  
  <author>
    <name><![CDATA[惊鸿三世]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript之this、call与apply]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/07/js-executionContext/"/>
    <id>http://blog.codingplayboy.com/2016/01/07/js-executionContext/</id>
    <published>2016-01-06T16:26:50.000Z</published>
    <updated>2016-01-06T16:42:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4Bthis_u3001call_u4E0Eapply"><a href="#JavaScript_u4E4Bthis_u3001call_u4E0Eapply" class="headerlink" title="JavaScript之this、call与apply"></a>JavaScript之this、call与apply</h1><p>在JavaScript学习中，this的重要性不明而寓，有必要对其深入学习，而与this息息相关的有两个特别需要注意的就是call，apply，本篇就着手从this开始阐述，而后介绍call、apply之用法。</p>
<blockquote>
<p>调用一个函数时代码执行控制权就转移到此函数，同时将参数传入此函数，除了声明函数时定义的形式参数，每个函数都会接受两个附加参数：this和arguments。</p>
</blockquote>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><strong>JavaScript中this总是指向一个对象，这个对象基于函数运行时的执行环境动态绑定，而非函数声明时所处环境。</strong></p>
<p><em><a href="http://blog.codingplayboy.com/2016/01/07/js-scope/">关于执行环境可查看本系列篇JavaScript之作用域与作用域链</a></em></p>
<h3 id="this_u6307_u5411"><a href="#this_u6307_u5411" class="headerlink" title="this指向"></a>this指向</h3><p>关于this指向问题，与函数调用息息相关，其可大致分为四类情况：</p>
<ul>
<li>(1). 方法调用； 即作为某对象的方法调用。</li>
<li>(2). 函数调用；即作为普通函数调用。</li>
<li>(3). 构造器函数调用；即以new方式调用。</li>
<li>(4). call与apply调用；即以Function.prototype.call或Function.prototype.apply调用。</li>
</ul>
<h4 id="u65B9_u6CD5_u8C03_u7528"><a href="#u65B9_u6CD5_u8C03_u7528" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === obj); <span class="comment">//输出true</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//输出Job</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>
<p><strong>当函数作为对象的方法被调用时，this总是指向该对象。</strong></p>
<h4 id="u51FD_u6570_u8C03_u7528"><a href="#u51FD_u6570_u8C03_u7528" class="headerlink" title="函数调用"></a>函数调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Job'</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">//输出true</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//输出Job</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">getName(); <span class="comment">//普通函数调用</span></span><br></pre></td></tr></table></figure>
<p><strong>非严格模式下，当函数作为普通函数方式调用时，不论该函数调用时所处执行环境为何，this总是指向全局对象，JavaScript中即是window对象。</strong></p>
<p>再看如下实例，加深理解：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> id = <span class="string">'windowId'</span>;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">//输出myDiv</span></span><br><span class="line">		<span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">//输出windowId</span></span><br><span class="line">		&#125;;</span><br><span class="line">		fn(); <span class="comment">//普通函数调用</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u6784_u9020_u5668_u51FD_u6570_u8C03_u7528"><a href="#u6784_u9020_u5668_u51FD_u6570_u8C03_u7528" class="headerlink" title="构造器函数调用"></a>构造器函数调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.name); <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p><strong>当用new调用构造器函数时，总会返回一个对象，该对象可以看成是构造器函数一个实例，一般，此时构造器里的this就指向返回的这个对象。</strong><br>但还需要注意的是当构造器显式地返回一个对象时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name: <span class="string">'Job'</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.name); <span class="comment">//输出Job</span></span><br></pre></td></tr></table></figure></p>
<p>此时，this指向的是构造器显式返回的对象。</p>
<h4 id="call_u4E0Eapply_u8C03_u7528"><a href="#call_u4E0Eapply_u8C03_u7528" class="headerlink" title="call与apply调用"></a>call与apply调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === obj); </span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">'Web'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName());  <span class="comment">//输出Job</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName.call(obj2)); <span class="comment">//输出Web</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName.apply(obj2)); <span class="comment">//输出Web</span></span><br></pre></td></tr></table></figure>
<p>当以Function.prototype.call或Function.prototype.apply方式调用函数时，动态传入参数改变执行环境，此时this指向传入的对象。</p>
<h2 id="call_u4E0Eapply"><a href="#call_u4E0Eapply" class="headerlink" title="call与apply"></a>call与apply</h2><p>call与apply是Function原型上定义的两个方法，其应用广泛。</p>
<h3 id="call_u4E0Eapply_u7684_u533A_u522B"><a href="#call_u4E0Eapply_u7684_u533A_u522B" class="headerlink" title="call与apply的区别"></a>call与apply的区别</h3><p>两者作用完全一样，不同之处在于传入参数的形式。</p>
<blockquote>
<p>call传入参数数量不固定，第一个参数代表所调用函数体内this的指向，而后依次为所调用函数所需参数。</p>
<p>apply接受最多两个参数，第一个参数指定被调用函数内this的指向，第二个参数为一个带下标的集合，可以是数组或者类数组，作为参数传给被调用函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var fn = function(a, b, b) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>([a, b, c]);</span><br><span class="line">&#125;;</span><br><span class="line">fn.call(null, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">fn.apply(null, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，非严格模式下，使用call或apply时，第一个参数是必须的，当第一个参数传入null时，函数体内this就会指向被调用函数的宿主对象(其包含对象)；而严格模式下，this指向则为null</strong></p>
<h3 id="call_u4E0Eapply_u7684_u5E94_u7528"><a href="#call_u4E0Eapply_u7684_u5E94_u7528" class="headerlink" title="call与apply的应用"></a>call与apply的应用</h3><h4 id="u6539_u53D8this_u6307_u5411"><a href="#u6539_u53D8this_u6307_u5411" class="headerlink" title="改变this指向"></a>改变this指向</h4><p>使用call或apply调用函数可改变函数体内this的指向。实例如前文中this指向相关实例。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h4><p>Function.prototype.bind可以用来绑定函数体内this指向，其参数为this的指向对象。IE8及以下不支持，这里我们可以自己实现一个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;  <span class="comment">//保存原函数的引用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//返回一个新函数</span></span><br><span class="line">		<span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>); <span class="comment">//将传入的参数指定为新函数体内this的指向对象</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">fn.bind(obj)();</span><br></pre></td></tr></table></figure></p>
<h4 id="u501F_u7528_u5176_u4ED6_u5BF9_u8C61_u7684_u65B9_u6CD5"><a href="#u501F_u7528_u5176_u4ED6_u5BF9_u8C61_u7684_u65B9_u6CD5" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h4><p>最熟悉的就是借用构造函数实现类似继承的效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Dog.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.getName());  <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure></p>
<p>另一很常见的情况就是借用Array.prototype对象上的方法处理函数参数类数组arguments:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); <span class="comment">//arguments为类数组[1,2,3]</span></span><br><span class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>); <span class="comment">//将arguments类数组剩余参数转换为数组赋给args变量</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//输出[2, 3]</span></span><br><span class="line">	<span class="built_in">console</span>.log(args); <span class="comment">//输出[2, 3]</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面借用Array.prototype上的shift方法移除参数列表的首位，当然也可以借用其他方法达到其他目的，如push, slice等。</p>
<p>JavaScript中，call与apply的应用是非常广泛的，在各类Js框架库中，都不难发现其身影。</p>
]]></content>
    <summary type="html">
    <![CDATA[在JavaScript学习中，this的重要性不明而寓，有必要对其深入学习，而与this息息相关的有两个特别需要注意的就是call，apply，本篇就着手从this开始阐述，而后介绍call、apply之用法。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="this" scheme="http://blog.codingplayboy.com/tags/this/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之作用域与作用域链]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/07/js-scope/"/>
    <id>http://blog.codingplayboy.com/2016/01/07/js-scope/</id>
    <published>2016-01-06T16:11:48.000Z</published>
    <updated>2016-01-06T16:23:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE"><a href="#JavaScript_u4E4B_u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="JavaScript之作用域与作用域链"></a>JavaScript之作用域与作用域链</h1><p>此篇阐述JavaScript中很重要的几个概念：作用域与作用域链及相关知识点，首先从变量与作用域的行为关系开始讨论。</p>
<h2 id="u53D8_u91CF_u4F5C_u7528_u57DF"><a href="#u53D8_u91CF_u4F5C_u7528_u57DF" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>JavaScript中，变量有全局变量及局部变量之分，而能定义变量作用域的语块只有函数。与局部变量有关的一种有趣特性，在此处不得不谈–变量提升。</p>
<h3 id="u53D8_u91CF_u63D0_u5347"><a href="#u53D8_u91CF_u63D0_u5347" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量提升为何物？</p>
<blockquote>
<p>JavaScript的变量声明会被提升到它们所在函数的顶部，而初始化仍旧在原来的地方。JavaScript引擎并没有重写代码：每次调用函数时，声明都会重新提升。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jog'</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prison</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>；<span class="comment">//局部变量</span></span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//输出1</span></span><br><span class="line">	<span class="built_in">console</span>.log(name); <span class="comment">//输出Jog</span></span><br><span class="line">&#125;</span><br><span class="line">prison();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jog'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prison</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Hans'</span>;</span><br><span class="line">&#125;</span><br><span class="line">prison();</span><br></pre></td></tr></table></figure>
<p><strong>此处name的声明被提升到函数的顶部，变量查找时先从局部作用域开始，未找到则由内而外最后到全局作用域。</strong></p>
<p>接下来我们详细分析一下JavaScript的提升方式。</p>
<h3 id="u53D8_u91CF_u63D0_u5347_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61"><a href="#u53D8_u91CF_u63D0_u5347_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61" class="headerlink" title="变量提升与执行环境对象"></a>变量提升与执行环境对象</h3><p>学习任何一门语言，都像学习魔术一样，初时引人迷惑，惊叹；然而当秘密被揭开时几乎令人失望，JavaScript不外如是。</p>
<h4 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h4><p>执行某代码块时，JavaScript引擎先解释，再运行。解释过程主要几个过程：</p>
<pre><code>- (1) 声明该作用域内var变量
- (2) 声明并初始化函数参数
- (3) 声明并初始化声明式函数
</code></pre><p><em><a href="https://github.com/codingplayboy/javascript_notes/blob/master/js_compileRun.md" target="_blank" rel="external">详细可查看本系列笔记JavaScript之解释与执行机制</a></em></p>
<h4 id="u6267_u884C_u73AF_u5883_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61"><a href="#u6267_u884C_u73AF_u5883_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61" class="headerlink" title="执行环境与执行环境对象"></a>执行环境与执行环境对象</h4><p><strong>执行环境（execution context）</strong>是一种概念，每当函数被调用都会产生一个新的执行环境。</p>
<blockquote>
<p><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
</blockquote>
<pre><code>- 1. 每个函数都有自己的执行环境。  当执行流进入一个函数时，执行环境就被推入一个环境栈中；函数执行之后，栈将其执行环境弹出，控制权返回到之前的执行环境。
- 2. 如果变量在当前执行环境内可访问，则该变量在当前作用域内。
- 3. JavaScript访问变量，其实就是访问该执行环境对象（变量对象）中的属性。
- 4. 全局执行环境是最外围的一个执行环境。
</code></pre><blockquote>
<p><strong>执行环境对象</strong>–每个执行环境都有一个与之对应的<strong>变量对象</strong>，执行环境中定义的所有变量和函数都保存在这个对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Far'</span>;</span><br><span class="line">	inner();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'inner'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<p>在调用fn时，其过程如下</p>
<pre><code>- 1. 创建一个空执行环境对象；
- 2. 声明参数并赋值；{arg: 1}
- 3. 声明局部变量；{arg:1, name: undefined}
- 4. 预定义声明式函数；{arg:1, name: undefined， inner: function(){console.log(&apos;inner&apos;);}}
- 5. 代码执行时，局部变量被赋值；{...name: &apos;Far&apos;...}
- 6. 执行环境对象上变量和函数属性保持不变，调用inner函数时，其内部会创建一个新的执行环境对象，依此可递归形成一条作用域链。
</code></pre><h2 id="u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE"><a href="#u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><blockquote>
<p>当一个变量在某执行回家内可以被访问，我们称该变量在当前<strong>作用域</strong>内。</p>
</blockquote>
<p>代码某一执行环境中执行时，会创建该<strong>执行环境对应的变量对象</strong>的一个作用域链。</p>
<blockquote>
<p>JavaScript引擎在执行环境对象中查找作用域内的变量或函数，其查找顺序由内而外向上直到全局执行环境对象，这个顺序就形成<strong>作用域链</strong>。</p>
</blockquote>
<p>作用域链的<strong>前端</strong>，始终是当前执行环境对应的变量对象。若此执行环境是函数，则将其活动对象作为变量对象。作用域链中的<strong>下一个</strong>变量对象来自于当前变量对象的包含（外部）执行环境，如此一直到全局执行环境；全局执行环境的变量对象始终是作用域链中的<strong>最后</strong>一个变量对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> country = <span class="string">'China'</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Java'</span>;</span><br><span class="line"><span class="keyword">var</span> job = <span class="string">'Web'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(age);  <span class="comment">//输出22</span></span><br><span class="line">	<span class="built_in">console</span>.log(country); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> country = <span class="string">'Union'</span>;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Python'</span>;</span><br><span class="line">	inner();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name); <span class="comment">//输出Python</span></span><br><span class="line">		<span class="built_in">console</span>.log(job); <span class="comment">//输出Web</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>代码输出结果如上：</p>
<pre><code>- 1. outer函数执行时，首先在outer执行环境对象中查找age和country变量结果country存在但并未初始化赋值，输出undefined;而age未找到于是沿着作用域链向上到全局执行环境，在其变量对象中存在age属性，于是输出其值22.
- 2. inner函数执行时创建自己的执行环境对象，其并没有定义name和job等变量，于是沿着作用域链向上到达outer函数的执行环境，在其变量对象中存在name于是输出其值Python；而未找到job于是继续向上直到全局执行环境，找到并输出其值，结束；若依然未找到，则会报错，停止运行。
</code></pre><p><strong>注：函数参数亦被当作变量对待，故其访问规则与普通变量相同。</strong></p>
<h3 id="u5EF6_u957F_u4F5C_u7528_u57DF_u94FE"><a href="#u5EF6_u957F_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>某些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行结束后移除。常见如：</p>
<ul>
<li>try-catch语句；<br>catch语句会创建一个新变量对象，包含被抛出的错误对象的声明。</li>
<li>with语句；<br>with语句会创建一个包含语句接收对象的所有属性和方法的变量对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAttr</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = data;</span><br><span class="line">	<span class="keyword">with</span>(obj) &#123;</span><br><span class="line">		<span class="keyword">var</span> o = location;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(o);</span><br><span class="line">&#125;</span><br><span class="line">getAttr(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>上面with语句接收window对象，其创建的变量对象就包含了window对象所有属性和方法，于是可以在其执行环节直接访问location变量，也就是正常的window.location。</p>
<p><em>强烈建议不要使用with语句。</em></p>
<p>本篇笔记阐述JavaScript执行环境与执行环境对象，变量对象，作用域与作用域链，耗时颇多，还有诸多不足之处待日后补充改进。</p>
]]></content>
    <summary type="html">
    <![CDATA[在JavaScript的进阶学习过程中，深入理解其作用域与作用域链必不可少，本篇主要阐述JavaScript执行环境与执行环境对象，变量对象，作用域与作用域链及其关系。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Scope" scheme="http://blog.codingplayboy.com/tags/Scope/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之原型与原型链]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-prototype/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-prototype/</id>
    <published>2016-01-06T13:44:22.000Z</published>
    <updated>2016-01-06T13:50:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE"><a href="#JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE" class="headerlink" title="JavaScript之原型与原型链"></a>JavaScript之原型与原型链</h1><p>在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。</p>
<h2 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h2><p>Javascript中创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的作用即是包含可以由特定类型实例共享的属性和方法，这个对象就是函数的原型对象。</p>
<p>默认情况，所有的原型对象都会有一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>调用构造函数创建一个新实例后，实例的内部将包含一个指向构造函数原型对象的指针，在ECMA-262中定义此指针为[[Prototype]]，并不能被显式的访问到，而在Firefox,Safari和Chrome中每个对象上有一个__proto__属性。</p>
<p><em>__proto__显示的是实例与构造函数原型对象间的关系，而非实例与构造函数间的关系。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.getName());  <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，Animal为构造函数，Animal.prototype指向构造函数原型对象；原型对象中constructor属性指向构造函数，即Animal.prototype.constructor指向Animal；在构造函数实例中，其__proto__属性指向构造函数原型对象。</p>
<h3 id="u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE"><a href="#u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE" class="headerlink" title="原型与实例属性访问"></a>原型与实例属性访问</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line">animal2.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出4--实例属性</span></span><br><span class="line"><span class="keyword">delete</span> animal2.age;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取某对象属性时，首先从该对象实例本身开始，若该实例中找到该属性，则返回该属性值；若未找到，则继续查找该实例对象指向的构造函数原型对象，若找到则返回值。</p>
</blockquote>
<p>(1) hasOwnProperty()方法<br>hasOwnProperty()方法可以检测一个属性是在原型上还是实例上，只有当给定属性为对象实例属性时返回true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line">animal1.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>(2) 原型与in<br>单独使用in操作符时，只要通过对象能访问到给定属性即返回true，无论属性是在实例还是原型上定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'eat'</span> <span class="keyword">in</span> animal1); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB"><a href="#u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB" class="headerlink" title="实例与原型的引用关系"></a>实例与原型的引用关系</h3><p>实例在创建时，其内部指针[[Prototype]](在上文提到的__proto__)指向构造函数原型对象，存在引用关系。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">animal.getName(); <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然实例早于原型中getName方法创建，但其依然可以调用该方法，因为实例通过引用指向原型对象，原型对象变化自然能被实例访问到。然而，对于如下这种情况：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: Animal,  //设置<span class="keyword">constructor</span>值为Animal，确保<span class="keyword">constructor</span>属性返回适当值，详细见上文关于<span class="keyword">constructor</span>属性说明</span><br><span class="line">	age: 3,</span><br><span class="line">	getName: function() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal2.getName());  <span class="comment">//输出Cat</span></span><br><span class="line">animal.getName();  <span class="comment">//TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>此处，首先创建了一个实例，随后重写了构造函数原型对象，再在实例上调用getName方法时报错；而重写构造函数原型对象之后创建的实例调用getName方法可以正常返回对应值。这是因为重写原型对象之后，之前创建的实例引用的依然是之前的原型对象，其与现有原型之间并无联系，而之后创建的实例[[Prototype]]指针引用的就是现有原型。</p>
<h3 id="u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898"><a href="#u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898" class="headerlink" title="原型对象存在问题"></a>原型对象存在问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.partner = [<span class="string">'one'</span>];</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one"] </span></span><br><span class="line">animal1.partner.push(<span class="string">'two'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner === animal2.partner); <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure>
<p>可以看到原型中所有属性都被实例共享，特别是对于引用类型的属性，如上的partner属性。</p>
<h3 id="u9ED8_u8BA4_u539F_u578B"><a href="#u9ED8_u8BA4_u539F_u578B" class="headerlink" title="默认原型"></a>默认原型</h3><p>所有引用类型默认都继承自Object，所有构造函数默认原型都是Object的实例，默认原型都会包含一个内部指针，指向Object.prototype。</p>
<h3 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB" class="headerlink" title="构造函数，原型与实例的关系"></a>构造函数，原型与实例的关系</h3><p>每个构造函数都有一个原型对象，由prototype属性指向；原型对象包含一个指向构造函数的指针constructor；而实例都包含一个指向构造函数原型对象的内部指针[[Prototype]]。</p>
<h2 id="u539F_u578B_u94FE"><a href="#u539F_u578B_u94FE" class="headerlink" title="原型链"></a>原型链</h2><p>每一个构造函数都有一个原型对象，当我们让某一原型对象等于另一构造函数的实例，此时该原型对象就包含一个指针，该指针指向这一构造函数的原型对象，该指针指向的原型对象中包含一个指向这一构造函数的指针，同样我们可以令该指针指向的原型对象等于另一构造函数的实例，如此递进，则形成一条实例与原型的链条，即原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.childname = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.getChildName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.childname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getName()); <span class="comment">//输出parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getChildName());  <span class="comment">//输出child</span></span><br></pre></td></tr></table></figure>
<p>如上代码，child实例指向Child原型，Child原型等于Parent实例，即指向Parent原型。可见本质即是以一个新类型（构造函数）的实例重写原型对象，形成原型链。</p>
<h3 id="u539F_u578B_u94FE_u95EE_u9898"><a href="#u539F_u578B_u94FE_u95EE_u9898" class="headerlink" title="原型链问题"></a>原型链问题</h3><p>既然原型对象存在问题，那么原型链自然也继承了这个问题，即原型属性会被所有实例共享，对于原型属性的改变将影响所有实例，而在原型链中，由于某一原型对象等于另一构造函数的实例，实例受影响，也就导致其他原型对象也受影响。</p>
<p>原型与原型链是JavaScript实现继承的基础，下一篇详细介绍JavaScript之继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Prototype" scheme="http://blog.codingplayboy.com/tags/Prototype/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之解释与执行机制]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-compileRun/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-compileRun/</id>
    <published>2016-01-06T13:09:50.000Z</published>
    <updated>2016-01-06T13:19:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236"><a href="#JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236" class="headerlink" title="JavaScript之解释与执行机制"></a>JavaScript之解释与执行机制</h1><p>不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。</p>
<blockquote>
<p>解释型语言：程序不需要编译，程序在运行时才<strong>翻译</strong>成机器语言，每执行一次都要翻译一次。</p>
<p>编译型语言：程序在执行之前需要一个专门的<strong>编译</strong>过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果。</p>
</blockquote>
<p><em>JavaScript翻译过程又做解释过程。</em></p>
<h2 id="JavaScript_u89E3_u91CA_u4E0E_u6267_u884C"><a href="#JavaScript_u89E3_u91CA_u4E0E_u6267_u884C" class="headerlink" title="JavaScript解释与执行"></a>JavaScript解释与执行</h2><p>JavaScript按照代码块来进行解释和执行，代码块间相互独立，但变量和方法共享。</p>
<blockquote>
<p>JavaScript中的代码块是指由<code>&lt;script&gt;&lt;/script&gt;</code>标签分割的代码段。</p>
</blockquote>
<h3 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h3><p>JavaScript代码块在执行时先由解释器进行解释，主要过程是声明所有var变量（并未初始化赋值，当前值为undefined）、解析<strong>声明式</strong>函数语句，而且是先预定义变量再预定义函数。</p>
<blockquote>
<p>JavaScript中函数定义主要主要有两种：声明式与函数表达式。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u7801_u5206_u6790"><a href="#u4EE3_u7801_u5206_u6790" class="headerlink" title="代码分析"></a>代码分析</h3><ol>
<li><strong>试分析以下代码：</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">var a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>弹出undefined和ok。因为执行时先解释：1.定义var变量，并未初始化赋值，当前值为undefined。</p>
<ol>
<li><strong>请君细看</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>会发现报错了，因为a未定义，解释时定义var变量，并不会定义此处的a。</p>
<p>到这里我们又发现了一个值得关注的问题–定义变量的方式。</p>
<blockquote>
<p>JavaScript变量分两种：全局变量和局部变量。像a = 1;这种定义默认是创建全局变量，其实就相当于window.a = 1;而var a = 1;这种格式是定义一个当前作用域下的变量。解释时只会定义var格式的变量。</p>
</blockquote>
<p>3.<strong>函数相关</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"函数表达式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok1'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"声明式函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok2'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如何呢？运行上述代码你会发现弹出了“声明式函数”和“ok2”。<br>为什么呢，这里就涉及到前面所说的<strong>代码块之间是相互独立的</strong>，故前面的a()虽然报错了，阻塞了ok1弹出；但是第二段script代码并不受影响。</p>
<p>第一段代码缘何报错？因为代码执行时先解释声明式函数而不会解释函数表达式，此时只是定义了a变量，未初始化，其值为undefined,不是函数。</p>
<p>到此时对JavaScript的解释与执行机制、顺序也算有初步的认识了。</p>
]]></content>
    <summary type="html">
    <![CDATA[不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。]]>
    
    </summary>
    
      <category term="Compile" scheme="http://blog.codingplayboy.com/tags/Compile/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之面向对象]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-object/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-object/</id>
    <published>2016-01-05T16:16:11.000Z</published>
    <updated>2016-01-06T13:12:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61"><a href="#JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61" class="headerlink" title="JavaScript之面向对象"></a>JavaScript之面向对象</h1><p>传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。</p>
<h2 id="u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B"><a href="#u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>何谓动态，何谓静态？编程语言按数据类型大体分为两类：动态类型语言，静态类型语言。</p>
<blockquote>
<p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行时，待变量被赋值后，才会具有某种类型。</p>
</blockquote>
<p>典型的静态类型语言有Java, C#等，而在JavaScript中，当我们为某变量赋值时，并不需要判断其类型，其显然是一门典型的动态类型语言。</p>
<h2 id="JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE"><a href="#JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE" class="headerlink" title="JavaScript对象和原型链"></a>JavaScript对象和原型链</h2><h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>与对象最紧密相关当然是变量了<br>JavaScript的中有五种简单数据类型（也称基本数据类型）以及一种复杂数据类型。<br>简单数据类型包括数字, 字符串, 布尔值（true和false）, null, undefined值。<br>复杂数据类型即Object。<strong>JavaScript中除了简单数据类型值，其他所有值均为对象。</strong></p>
<h4 id="JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C"><a href="#JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C" class="headerlink" title="JavaScript变量之基本类型值与引用类型值"></a>JavaScript变量之基本类型值与引用类型值</h4><p>JavaScript变量可能包含两种不同数据类型的值：基本数据类型值和引用类型值。将一个值赋给变量时，解析器会判断这个值的类型。</p>
<blockquote>
<p>基本类型值指的是简单的数据段，是按值访问的，可以操作保存在变量中的实际值；而引用类型值指那些可能由多个值构成的对象，是引用类型的一个实例，是按引用访问的。</p>
</blockquote>
<ul>
<li><strong>基本类型</strong> 即包括如前所述的五种。</li>
<li><strong>引用类型</strong> 一种数据结构，用以描述对象的属性和方法。</li>
</ul>
<p><em>注：引用类型值和引用类型不同。</em></p>
<p>JavaScript引用类型主要包括Object，Array，Date，RegExp，Function以及为了操作基本类型值提供的三个特殊引用类型：Boolean，Number和String。<strong>可以说，JavaScript中对象即是某种引用类型的实例，我们使用的大多数引用类型值又都是Object类型的实例。</strong></p>
<h3 id="JavaScript_u521B_u5EFA_u5BF9_u8C61"><a href="#JavaScript_u521B_u5EFA_u5BF9_u8C61" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h3><p>不同于许多传统面向对象语言使用基于类的对象，JavaScript使用基于原型的对象。</p>
<ul>
<li><strong>对象字面量</strong> 一个对象字面量就是在一对花括号中的零或多个名值对。</li>
<li><strong>Object构造函数</strong> 调用Object构造函数，可使用new Object()形式创建对象。<em>Object.create()方式创建对象亦很常见。</em></li>
</ul>
<h3 id="JavaScript_u7EE7_u627F"><a href="#JavaScript_u7EE7_u627F" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h3><p>继承（Object Orient）向来是面向对象语言最突出特征之一，如Java等传统OO语言都支持基于类的继承，而JavaScript中是没有类的概念，其主要依靠原型链实现继承。</p>
<blockquote>
<p>基于原型链的委托机制就是原型继承的本质，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<h4 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h4><p>对象的原型，就JavaScript真正实现而言，其实对象并无原型，而是对象的构造器（构造函数）与原型。所谓‘对象把请求委托给自己的原型’即是把请求委托给其构造器原型。JavaScript对象的__proto__属性默认即指向其构造器原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B" class="headerlink" title="构造函数，原型与实例"></a>构造函数，原型与实例</h4><p><strong>每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而构造函数的实例都包含一个指向原型对象的内部指针。JavaScript中所有对象都默认继承自根对象Object。</strong></p>
<p>给一个构造函数的原型对象赋值为另一个类型的实例，此时原型对象即包含指向另一原型对象的指针，而另一个原型对象中也包含指向其相应构造函数的指针，如此便构成了原型与实例的关系链，也即原型链。依此可实现不同对象间的属性和方法的继承。</p>
<ul>
<li><strong>默认原型</strong> 所有引用类型默认都继承了Object，所有函数的默认原型都是Object实例，而如前所述：构造函数的实例都包含一个指向原型对象的内部指针，因此默认原型都包含一个指向Object.prototype（即Object原型）的内部指针。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="string">'Animal'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getAnimalProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">this</span>.dogproperty = <span class="string">'Dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承自Animal</span></span><br><span class="line">Dog.prottotype.getDogProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>. dogproperty; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">alert(dog.getDogProperty);</span><br><span class="line">alert(dog.getAnimalProperty);</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>对象的根对象</strong> JavaScript对象都源于（继承自）根对象Object。</li>
<li><strong>对象源自克隆</strong> 定义对象，不是通过实例化类，而是把另一对象作为原型并克隆之。</li>
<li><strong>对象记忆性</strong> 请求可以在原型链中依此向后传递，每个对象都会记住自己的原型，详细请回顾上文关于对象原型之说的__proto__属性。</li>
<li><strong>对象请求传递性</strong> 若当前对象无法响应当前请求，便将其委托给其构造器原型。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Object Oriented" scheme="http://blog.codingplayboy.com/tags/Object-Oriented/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/04/hello-world/"/>
    <id>http://blog.codingplayboy.com/2016/01/04/hello-world/</id>
    <published>2016-01-03T16:16:11.000Z</published>
    <updated>2016-01-06T13:32:25.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on GitHub.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/categories/Hexo/"/>
    
  </entry>
  
</feed>

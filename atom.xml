<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[惊鸿三世的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.codingplayboy.com/"/>
  <updated>2016-01-08T16:50:17.000Z</updated>
  <id>http://blog.codingplayboy.com/</id>
  
  <author>
    <name><![CDATA[惊鸿三世]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript之闭包与高阶函数（一）]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/09/js-closureFunc/"/>
    <id>http://blog.codingplayboy.com/2016/01/09/js-closureFunc/</id>
    <published>2016-01-08T16:42:46.000Z</published>
    <updated>2016-01-08T16:50:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u95ED_u5305_u4E0E_u9AD8_u9636_u51FD_u6570_uFF08_u4E00_uFF09"><a href="#JavaScript_u4E4B_u95ED_u5305_u4E0E_u9AD8_u9636_u51FD_u6570_uFF08_u4E00_uFF09" class="headerlink" title="JavaScript之闭包与高阶函数（一）"></a>JavaScript之闭包与高阶函数（一）</h1><p>JavaScript虽是一门面向对象的编程语言，但同时也有许多函数式编程的特性，如Lambda表达式，闭包，高阶函数等。</p>
<blockquote>
<p>函数式编程是种编程范式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值</p>
</blockquote>
<h2 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h2><p>何谓闭包？对于闭包众位各有己见，今我试说之，<strong>闭包，常指有权访问其外部作用域中变量和参数的函数。</strong>最常见的就是在某函数内部创建另一个函数。如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">            item += <span class="keyword">typeof</span> num === <span class="string">'number'</span> ? num : <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><em>此处把函数返回的结果赋值给count，该函数返回一个包含两个方法的对象，对象中的方法均可访问其包含函数中的变量及参数。count中保存的是该对象的一个引用，对象中的方法依然可以访问自执行函数中的变量，而且访问的是变量本身。</em></p>
<blockquote>
<p>闭包 函数可以访问它创建时所处的上下文环境中的变量以及参数，this以及arguments除外。</p>
</blockquote>
<p>闭包其实并不是很好阐述，与我而言，自我理解与向他人阐述差别甚大，但也要试着去征服它。闭包的形成与变量息息相关，尤其是变量的作用以及变量生命周期，请看细说：</p>
<h3 id="u95ED_u5305_u4E0E_u53D8_u91CF"><a href="#u95ED_u5305_u4E0E_u53D8_u91CF" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p><strong>闭包中所保存的是整个变量对象–执行环境（上下文环境）中的一个表示变量的对象的引用，访问执行环境中变量即是访问该变量对象中的变量。</strong></p>
<blockquote>
<p>变量对象 每个执行环境（上下文环境）中的一个表示所有变量的对象，全局环境的变量对象始终存在，而局部环境的变量对象只在其执行过程中存在。</p>
</blockquote>
<p>典型案例如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        count[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数会返回一个函数数组，这个数组会不会乖乖返回自己的数字呢？当然不会，事实上，每个函数都返回10。为什么呢？细细道来，因为每个函数的作用域链中都保存着myNumber()函数的活动对象（变量对象），他们都引用同一个变量对象，当然也引用同一个变量i,当myNumber()函数返回后i为10。</p>
<p>再看如下代码：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        count[i] = （<span class="function"><span class="keyword">function</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此将自执行匿名函数结果赋值给数组，调用每个匿名函数时，传入变量i，而函数参数是<strong>按值传递</strong>，即将变量值复制给参数num，在此匿名函数内部又创建并返回了一个访问num参数的闭包，count数组中的函数均保存有自己的num变量的副本，于是，便返回各自的值了。</p>
<h4 id="u53D8_u91CF_u7684_u4F5C_u7528_u57DF"><a href="#u53D8_u91CF_u7684_u4F5C_u7528_u57DF" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>变量分全局变量与局部变量，在函数中声明变量时，以var关键字定义的变量即是局部变量，而不带var关键字的就变成全局变量。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="title">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    alert(b);<span class="comment">//2</span></span><br><span class="line">    alert(<span class="built_in">c</span>);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span><span class="params">()</span></span>;</span><br><span class="line">alert(b);<span class="comment">//2</span></span><br><span class="line">alert(a);<span class="comment">//Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>我们知道，<strong>在函数中查找变量时，首先在当前函数执行环境作用域查找，若未找到，则随当前执行环境创建的作用域链往外层查找，直到全局对象为止，这里的查找是从内向外查找的</strong></p>
<p>####变量的生命周期</p>
<p>上面说到变量作用域，这里谈谈变量生命周期：</p>
<ul>
<li><strong>全局变量</strong>，其生命周期在整个程序运行时间内永久存在，除非主动销毁，否则可以随时调用。</li>
<li><strong>局部变量</strong>， 其在所属作用域代码执行过程中存在，当运行完成，且不存在外部调用此上下文环境中的变量时，即被销毁，否则依然存在。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="title">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> function() &#123;</span><br><span class="line">        alert(res[a]);</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="func"><span class="keyword">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span><span class="params">()</span></span>();<span class="comment">//1</span></span><br><span class="line"><span class="func"><span class="keyword">func</span><span class="params">()</span></span>();<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">f();<span class="comment">//1</span></span><br><span class="line">f();<span class="comment">//2</span></span><br><span class="line">f();<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>试比较执行fun()()与f()的弹出值，是不一样的，貌似在f()中a一直存在。当执行var f = func();时，f函数返回的是一个匿名函数的引用，此匿名函数可以访问func()被调用时的上下文环境（执行环境），局部变量即在其中，局部变量所处环境能被外界访问，局部变量就不会被销毁。</p>
<h3 id="u95ED_u5305_u7684_u4F5C_u7528"><a href="#u95ED_u5305_u7684_u4F5C_u7528" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><h4 id="u5C01_u88C5_u53D8_u91CF"><a href="#u5C01_u88C5_u53D8_u91CF" class="headerlink" title="封装变量"></a>封装变量</h4><p>闭包可以封装形成‘私有变量‘，如:实现计算乘积:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">alert(mult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="u6A21_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF"><a href="#u6A21_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h4><p>JavaScript中是没有块级作用域的概念的，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">function <span class="title">block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var res = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        alert(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    var i;<span class="comment">//重新声明变量</span></span><br><span class="line">    alert(i);<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码所见，i变量定义后在整个包含函数中均可访问。<strong>JavaScript中for语句并不会形成块级作用域，其整个作用域是包含函数创建的，而且对变量的后续声明都将被忽略。</strong><br>要达到块级作用域效果，我们可以形成闭包来模仿之，如：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span> <span class="collection">&#123;</span><br><span class="line">    //块级作用域</span><br><span class="line">&#125;</span>)</span><span class="list">()</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u6DFB_u52A0_u79C1_u6709_u53D8_u91CF_u6216_u51FD_u6570"><a href="#u6DFB_u52A0_u79C1_u6709_u53D8_u91CF_u6216_u51FD_u6570" class="headerlink" title="添加私有变量或函数"></a>添加私有变量或函数</h4><p>通过在私有作用域定义私有变量或函数，可以形成私有成员，如：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'xjg'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reutn name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>&#123;</span><br><span class="line">        name = val;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Anagle'</span>);</span><br><span class="line">alert(p1.getName());<span class="comment">//Anagle</span></span><br><span class="line">alert(getName())<span class="comment">//ReferenceError: getName is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>此处，name就变成了一个静态私有变量。</p>
<h3 id="u95ED_u5305_u4E0E_u5185_u5B58_u6CC4_u6F0F"><a href="#u95ED_u5305_u4E0E_u5185_u5B58_u6CC4_u6F0F" class="headerlink" title="闭包与内存泄漏"></a>闭包与内存泄漏</h3><p>局部变量本来在函数退出时被销毁，然而闭包中不是这样，局部变量生命周期被延长，闭包将使这些数据无法及时销毁，会占用内存，容易造成内存泄漏。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'myNode'</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处，onclick匿名函数保存了一个对包含函数活动对象（变量对象）的引用，其保存element的引用，element将不会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'myNode'</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;</span><br><span class="line">    element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处将element设为null，即解除对其的引用，垃圾回收器将回收其占用内存。</p>
<p>此篇对JavaScript闭包做了总结，阐述，限于篇幅，在下篇讲述JavaScript中的高阶函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript虽是一门面向对象的编程语言，但同时也有许多函数式编程的特性，如Lambda表达式，闭包，高阶函数等。此篇对JavaScript闭包做了总结，阐述，限于篇幅，在下篇讲述JavaScript中的高阶函数。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="closure" scheme="http://blog.codingplayboy.com/tags/closure/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript数组值之排序、去重及最值操作]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/08/js-arrAlgorithm/"/>
    <id>http://blog.codingplayboy.com/2016/01/08/js-arrAlgorithm/</id>
    <published>2016-01-07T16:59:38.000Z</published>
    <updated>2016-01-07T17:05:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u6570_u7EC4_u503C_u4E4B_u6392_u5E8F_u3001_u53BB_u91CD_u53CA_u6700_u503C_u64CD_u4F5C"><a href="#JavaScript_u6570_u7EC4_u503C_u4E4B_u6392_u5E8F_u3001_u53BB_u91CD_u53CA_u6700_u503C_u64CD_u4F5C" class="headerlink" title="JavaScript数组值之排序、去重及最值操作"></a>JavaScript数组值之排序、去重及最值操作</h1><p>本篇主要总结常见的排序算法在JavaScript中的实现及js数组取最值，去重，篇幅较长，如有需要可以跳越阅读。</p>
<h2 id="JavaScript_u4E4B_u6700_u503C"><a href="#JavaScript_u4E4B_u6700_u503C" class="headerlink" title="JavaScript之最值"></a>JavaScript之最值</h2><p>想一想给你一个数组，让你取最值，你会如何实现呢？这里我们只给出取最大值的实例。</p>
<h3 id="u904D_u5386"><a href="#u904D_u5386" class="headerlink" title="遍历"></a>遍历</h3><p>上代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    var temp = arr<span class="matrix">[<span class="number">0</span>]</span>;</span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) <span class="cell">&#123;</span><br><span class="line">        if (arr[i] &gt; temp) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="apply_u501F_u7528Math-max_28_29"><a href="#apply_u501F_u7528Math-max_28_29" class="headerlink" title="apply借用Math.max()"></a>apply借用Math.max()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apply有两个参数,第一个参数为执行环境，一个以数组形式传入参数。</p>
<p><em>更多关于apply及call的内容请点此查看本系列篇<a href="http://blog.codingplayboy.com/2016/01/07/js-executionContext/">JavaScript之this、call与apply</a>。</em></p>
<h2 id="JavaScript_u4E4B_u6392_u5E8F_u7B97_u6CD5"><a href="#JavaScript_u4E4B_u6392_u5E8F_u7B97_u6CD5" class="headerlink" title="JavaScript之排序算法"></a>JavaScript之排序算法</h2><p>主要介绍最常用的几种排序算法的JavaScript实现：桶排序，冒泡排序，快速排序。</p>
<h3 id="u6876_u6392_u5E8F"><a href="#u6876_u6392_u5E8F" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote>
<p>将数组分到有限数量的桶里，数组项值对应桶的编号，桶里的值则是其编号对应相等的数组项值出现的次数，然后，根据桶里的值将桶的编号依次输出。</p>
</blockquote>
<p>试想一下，你们五个小伙伴考试微积分，分别考了5分，6分，3分，8分，6分，接下来按分数高低进行排名。<br>如何实现呢？<br>这里我们只需要一个数组就能轻易解决：</p>
<p><em>大数组下标为待排序数组项的值，大数组值为其对应下标在待排序数组中出现次数，默认为0。大数组长度为待排序数组中最大值加1（因为下标从0开始）。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">barrelSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> _arr = [];</span><br><span class="line">	<span class="keyword">var</span> _max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr); <span class="comment">//借用取数组最大值</span></span><br><span class="line">	<span class="keyword">var</span> _num = _max + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((_num--) &gt;= <span class="number">0</span>) &#123; <span class="comment">//生成一个大一维数组，长度为数组最大值+1</span></span><br><span class="line">		_arr[_num] = <span class="number">0</span>;<span class="comment">//初始化大数组项全为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> _len = arr.length;</span><br><span class="line">	<span class="keyword">while</span> ((_len--) &gt;= <span class="number">0</span>) &#123;<span class="comment">//循环数组</span></span><br><span class="line">		_arr[arr[_len]]++;<span class="comment">//将数组项值对应为大数组下标,并统计数组项值出现次数，存入大数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> _item = _max + <span class="number">1</span>;</span><br><span class="line">	arr = [];<span class="comment">//重新生成排序后的数组</span></span><br><span class="line">	<span class="keyword">while</span> ((_item--) &gt;= <span class="number">0</span>)  &#123;<span class="comment">//循环大数组</span></span><br><span class="line">		<span class="keyword">var</span> k = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>((k++) &lt;= _arr[_item]) &#123;<span class="comment">//统计大数组中出现次数大于0的下标值，并存入数组</span></span><br><span class="line">			arr.push(_item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(arr);</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度O(m+n)</strong> </li>
</ul>
<p><em>如代码，第一个while循环m次（m为桶个数，即待排序数组最大值+1），第二个while循环n次(n为待排序数组长度)，最后嵌套while循环m+n次，即先循环大数组，然后只统计大数组中值大于0的对应下标，其实也就等于待排序数组长度，所以整个排序算法一共循环2</em>（m+n）次，其时间复杂度可为O(m+n)。</p>
<h3 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>何谓冒泡排序呢，先来理解一下：</p>
<blockquote>
<p>重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。因为越大的元素会经由交换慢慢“浮”到数列的顶端，故得名–冒泡。</p>
</blockquote>
<ul>
<li><strong>趟</strong> 从0开始循环到数组倒数第二个数，每次循环称为一趟。</li>
<li><strong>冒泡</strong> 从第一位数一直循环到倒数第二位数，依次两两比较，一次比较为一次冒泡。</li>
</ul>
<p><em>冒泡排序中一趟循环确定一位数字的正确位置，每趟循环都需要从当前数组序列的第一位数到倒数第二位数依次进行冒泡循环，最终确定排序后的数组序列。</em></p>
<p>请看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function">function <span class="title">bubbleSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">   	var _len = arr.length - <span class="number">1</span>;</span><br><span class="line">	var t;</span><br><span class="line">	<span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; _len; i++) &#123;<span class="comment">//从0开始循环到数组倒数第二个数，每次循环称为一趟</span></span><br><span class="line">		<span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; _len - i; j++) &#123;<span class="comment">//从第一位数一直循环到倒数第二位数，每次循环为有若干次冒泡</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;<span class="comment">//比较两个数大小，根据要求交换位置，即冒泡，结束后进行下一次冒泡</span></span><br><span class="line">				t = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.<span class="built_in">log</span>(arr);</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度O(N^2)</strong> </li>
</ul>
<p>如代码所示，冒泡排序算法只有一个双重嵌套循环，共循环n*n次，其时间复杂度即为O(N^2)。</p>
<h3 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序，可谓最常用的排序算法，也是目前提到的平均时间复杂度最快的算法，先来了解一下：</p>
<blockquote>
<p>找一个基准数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比基准数要小，另一部分的所有数据都比基准数要大，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<ul>
<li><strong>基准数</strong> 一个参照数，用来将待排序数列分割成两部分。</li>
<li><strong>哨兵</strong> 勘探待排序数组值依次与基准数进行比较的标记，以找到合格数（分别大于和小于基准数的两个数）。</li>
<li><strong>趟</strong> 一趟排序找一个基准数，然后选取从左至右与从右至左同时进行勘探。</li>
</ul>
<p><em>一般基准数我们取数组第一位数。两个哨兵分别为待排序数组首尾项。</em></p>
<p>直接上代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   function <span class="built_in">quickSort</span>(arr) &#123;</span><br><span class="line">   	function _sort(<span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> _left = <span class="keyword">left</span>, _right = <span class="keyword">right</span>;</span><br><span class="line">		<span class="keyword">var</span> temp;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">left</span> &gt; <span class="keyword">right</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = arr[<span class="keyword">left</span>];</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">left</span> != <span class="keyword">right</span>) &#123;</span><br><span class="line">			<span class="comment">//从右往左查找</span></span><br><span class="line">			<span class="keyword">while</span> (arr[<span class="keyword">right</span>] &gt;= temp &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;<span class="comment">//如果哨兵标记的数大于等于基准数则继续‘向前’，标记下一个数</span></span><br><span class="line">				<span class="keyword">right</span>--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//从左往右查找</span></span><br><span class="line">			<span class="keyword">while</span> (arr[<span class="keyword">left</span>] &lt;= temp &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;<span class="comment">//如果哨兵标记的数小于等于基准数则继续‘向前’，标记下一个数</span></span><br><span class="line">				<span class="keyword">left</span> ++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//交换两个数位置</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;<span class="comment">//两个哨兵均已找到目标数，如果两个哨兵未相遇，则交换当前两个哨兵所指向的目标数</span></span><br><span class="line">				temp = arr[<span class="keyword">left</span>];</span><br><span class="line">				arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>];</span><br><span class="line">				arr[<span class="keyword">right</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将此趟基准数交换至正确位置（小于基准数的数列与大于基准数的数列之间）</span></span><br><span class="line">		temp = arr[_left];</span><br><span class="line">		arr[_left] = arr[<span class="keyword">left</span>];</span><br><span class="line">		arr[<span class="keyword">left</span>] = temp;</span><br><span class="line">		_sort(_left, <span class="keyword">left</span> - <span class="number">1</span>);<span class="comment">//对分割后的两部分数列递归</span></span><br><span class="line">		_sort(<span class="keyword">left</span> + <span class="number">1</span>, _right);</span><br><span class="line">	&#125;</span><br><span class="line">       _sort(<span class="number">0</span>, arr.length - <span class="number">1</span>);<span class="comment">//开始快排</span></span><br><span class="line">	console.log(arr);</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度平均O(NlogN)</strong></li>
</ul>
<p>如代码示，最坏情况发生时，每次划分过程产生的两个数列分别包含n-1个元素和1个元素，此时相当于有两层嵌套循环，时间复杂度为O(N^2),与冒泡排序一致，而最好情况下，每次划分产生的两个数列长度大致相等，时间复杂度为O(NlogN)。</p>
<p><strong>尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。它的平均时间复杂度为O(nlgn)。</strong></p>
<h2 id="JavaScript_u6570_u7EC4_u53BB_u91CD"><a href="#JavaScript_u6570_u7EC4_u53BB_u91CD" class="headerlink" title="JavaScript数组去重"></a>JavaScript数组去重</h2><p>关于数组去重，也有很多种方法，在此给出几种效率最高的，借鉴一二。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   /** 第一种 */</span><br><span class="line">   function uniqueArray(arr) &#123;</span><br><span class="line">       <span class="keyword">var</span> res = [arr[<span class="number">0</span>]];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) //从第二项开始遍历</span><br><span class="line">   	&#123;</span><br><span class="line">   		//若数组第i项在当前数组中下标不是i，则说明第i项重复，应忽略。否则存入结果数组</span><br><span class="line">   		<span class="keyword">if</span> (arr.indexOf(arr[i]) == i) ｛</span><br><span class="line">               res.push(arr[i]);</span><br><span class="line">           ｝</span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 第二种 */</span><br><span class="line">   function uniqueArray(arr) &#123;</span><br><span class="line">   	<span class="keyword">var</span> _hash = &#123;&#125;, <span class="literal">result</span> = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!_hash[arr[i]]) &#123;</span><br><span class="line">			_hash[arr[i]] = <span class="literal">true</span>; //将首次遍历到的数组项存入hash对象，效率比indexOf快得多</span><br><span class="line">			<span class="literal">result</span>.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：此篇虽篇幅略长，但细细读来，想来还是能有些收获，足矣。</p>
]]></content>
    <summary type="html">
    <![CDATA[本篇笔记主要总结常见的排序算法在JavaScript中的实现及JavaScript数组取最值，去重的实现，篇幅较长，如有需要，可跳跃阅读；然学习非一朝一夕之事，而在于点滴积累，读完本篇总会有些收获，愿与君共同进步。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="algorithm" scheme="http://blog.codingplayboy.com/tags/algorithm/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
      <category term="algorithm" scheme="http://blog.codingplayboy.com/categories/JavaScript/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之Load与ready]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/08/js-domReady/"/>
    <id>http://blog.codingplayboy.com/2016/01/08/js-domReady/</id>
    <published>2016-01-07T16:19:58.000Z</published>
    <updated>2016-01-07T16:25:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4BLoad_u4E0Eready"><a href="#JavaScript_u4E4BLoad_u4E0Eready" class="headerlink" title="JavaScript之Load与ready"></a>JavaScript之Load与ready</h1><p>本篇笔记要谈的就是耳熟能详的window的load事件，及其与目前流行的jQuery中的ready事件的区别，最后简易实现一个domReady函数。</p>
<h2 id="load_u4E8B_u4EF6"><a href="#load_u4E8B_u4EF6" class="headerlink" title="load事件"></a>load事件</h2><p>window的load事件是JavaScript中最常用的事件之一，当页面完全加载完后（包括所有图片、JavaScript文件、CSS文件等资源），才触发load事件。有两种定义load事件的方式：</p>
<h3 id="u901A_u8FC7JavaScript_u6CE8_u518Cload_u4E8B_u4EF6"><a href="#u901A_u8FC7JavaScript_u6CE8_u518Cload_u4E8B_u4EF6" class="headerlink" title="通过JavaScript注册load事件"></a>通过JavaScript注册load事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;  <span class="comment">//非IE浏览器注册事件处理程序</span></span><br><span class="line">		elem.addEventListener(type, handler);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;  <span class="comment">//IE浏览器注册事件处理程序</span></span><br><span class="line">		elem.attachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		elem[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">addHandler(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Loaded!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="u901A_u8FC7_u4E3Abody_u5143_u7D20_u6DFB_u52A0onload_u7279_u6027"><a href="#u901A_u8FC7_u4E3Abody_u5143_u7D20_u6DFB_u52A0onload_u7279_u6027" class="headerlink" title="通过为body元素添加onload特性"></a>通过为body元素添加onload特性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"alert('Loaded')"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>注：页面中只能有一个基于window的load事件</em></p>
<h2 id="jQuery_u4E4Bready"><a href="#jQuery_u4E4Bready" class="headerlink" title="jQuery之ready"></a>jQuery之ready</h2><p>jQuery的ready事件是在形成完整的DOM树之后便会触发，不必等到所有外部资源加载完。<br>其定义形式如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//DOM操作...</span></span><br><span class="line">&#125;)</span><br><span class="line">或</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//DOM操作...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><em>注：页面中只有一个基于window的load事件能执行，而$(document).ready()可以同时编写多个，并且都可以得到执行。</em></p>
<h2 id="DOMContentLoaded_u4E8B_u4EF6"><a href="#DOMContentLoaded_u4E8B_u4EF6" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h2><p>与window的load事件不同，DOMContentLoaded事件与jQuery的ready事件一样在形成完整的DOM树之后便会触发，可以为window或document添加相应事件处理程序，然而其在IE中并不支持，下文有详解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addHandler函数与上文load事件处同</span></span><br><span class="line">addHandler(<span class="built_in">document</span>, <span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Content Loaded!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="IE_u4E0E_u6587_u6863_u52A0_u8F7D"><a href="#IE_u4E0E_u6587_u6863_u52A0_u8F7D" class="headerlink" title="IE与文档加载"></a>IE与文档加载</h2><p>IE中以readystatechange事件提供文档或元素的加载状态相关信息，支持readystatechange事件的对象均有一个readyState属性。</p>
<blockquote>
<p>readyState可能包含下列五个值之一：<br>uninitialized(未初始化)：对象存在但尚未初始化。<br>loading(正在加载)：对象正在加载数据。<br>loaded(加载完毕)：对象加载数据完成。<br>interactive(交互)：可以操作对象，但没有完全加载。<br>complete(完成)：对象已经加载完毕。</p>
</blockquote>
<h2 id="JavaScript_u6A21_u62DF_u5B9E_u73B0ready_u4E8B_u4EF6"><a href="#JavaScript_u6A21_u62DF_u5B9E_u73B0ready_u4E8B_u4EF6" class="headerlink" title="JavaScript模拟实现ready事件"></a>JavaScript模拟实现ready事件</h2><p>此段实现借鉴自半年前于慕课网所学笔记。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReady</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, fn, <span class="literal">false</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		IEContentLoaded(fn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">IEContentLoaded</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">var</span> d = <span class="built_in">window</span>.document;</span><br><span class="line">		<span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="comment">//只能执行一次</span></span><br><span class="line">			<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">				done = <span class="literal">true</span>;</span><br><span class="line">				fn();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				d.documentElement.doScroll(<span class="string">'left'</span>); </span><br><span class="line">				<span class="comment">//IE8及以下浏览器在文档DOM树未加载完时执行doScroll()会抛出错误跳到catch内执行</span></span><br><span class="line">			&#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">				setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">50</span>);</span><br><span class="line">				<span class="comment">//文档DOM树未加载完，50ms后再次运行本自执行函数以探测文档DOM树是否加载完成</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//递归探测文档DOM树是否加载完成</span></span><br><span class="line">			&#125;</span><br><span class="line">			init();</span><br><span class="line">		&#125;)();</span><br><span class="line">		d.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (d.readyState== <span class="string">'interactive'</span> || d.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line">				d.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">				<span class="comment">//移除相应事件处理程序以免其他阶段再次执行</span></span><br><span class="line">				init();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是一个简易的原生实现的ready函数，其功能与jQuery的ready相似。</p>
]]></content>
    <summary type="html">
    <![CDATA[本篇笔记要谈的就是耳熟能详的window的load事件，及其与目前流行的jQuery中的ready事件的区别，最后简易实现一个domReady函数。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="load" scheme="http://blog.codingplayboy.com/tags/load/"/>
    
      <category term="ready" scheme="http://blog.codingplayboy.com/tags/ready/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之树列表插件实现]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/07/js-treeViewPlugin/"/>
    <id>http://blog.codingplayboy.com/2016/01/07/js-treeViewPlugin/</id>
    <published>2016-01-07T14:07:32.000Z</published>
    <updated>2016-01-07T14:13:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u6811_u5217_u8868_u63D2_u4EF6_u5B9E_u73B0"><a href="#JavaScript_u4E4B_u6811_u5217_u8868_u63D2_u4EF6_u5B9E_u73B0" class="headerlink" title="JavaScript之树列表插件实现"></a>JavaScript之树列表插件实现</h1><p>treeViewPlugin，一个可以生成任意多级树列表的js插件，使用了jquery事件委托处理跨浏览器添加事件监听及DOM操作实现需求。<a href="https://github.com/codingplayboy/javascriptDemo/tree/master/treeViewPlugin" target="_blank" rel="external">查看插件源码点此</a></p>
<h2 id="API_u8BF4_u660E"><a href="#API_u8BF4_u660E" class="headerlink" title="API说明"></a>API说明</h2><h3 id="u63D2_u4EF6_u5B9A_u4E49"><a href="#u63D2_u4EF6_u5B9A_u4E49" class="headerlink" title="插件定义"></a>插件定义</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> treeViewPlugin = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;  <span class="comment">//插件定义、封装</span></span><br><span class="line">	<span class="comment">//插件实现</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h3 id="u63D2_u4EF6API"><a href="#u63D2_u4EF6API" class="headerlink" title="插件API"></a>插件API</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">return</span> &#123;</span><br><span class="line">	<span class="attribute">initModule</span>: initModule,  <span class="comment">//初始化树列表</span></span><br><span class="line">	<span class="attribute">addParents</span>: addParents,  <span class="comment">//给树列表添加父级菜单</span></span><br><span class="line">       	<span class="attribute">addChild</span>: addChild,  <span class="comment">//给树列表添加子级菜单</span></span><br><span class="line">       	<span class="attribute">addChildNode</span>: addChildNode  <span class="comment">//给树列表添加无子级的子级菜单</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * [initModule 初始化树列表]</span><br><span class="line"> * @param  &#123;[type]&#125; <span class="variable">$append</span>_target [树列表容器]</span><br><span class="line"> *	 $(<span class="string">'.treeviewCont'</span>)</span><br><span class="line"> * @<span class="keyword">return</span> &#123;[type]&#125;                [函数返回值]</span><br><span class="line"> */</span><br><span class="line">initModule = <span class="keyword">function</span>(<span class="variable">$append</span>_target) &#123;</span><br><span class="line">	//具体实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u6DFB_u52A0_u7236_u7EA7_u83DC_u5355"><a href="#u6DFB_u52A0_u7236_u7EA7_u83DC_u5355" class="headerlink" title="添加父级菜单"></a>添加父级菜单</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> [addParents 添加父级菜单</span><br><span class="line"> <span class="keyword">*</span> <span class="comment">@param &#123;[Array]&#125; _data [菜单数据]</span></span><br><span class="line"> <span class="keyword">*</span> [&#123;</span><br><span class="line"> <span class="keyword">*</span> 		id: 菜单id,</span><br><span class="line"> <span class="keyword">*</span> 		name: 菜单显示值</span><br><span class="line"> <span class="keyword">*</span> </span><br><span class="line"> <span class="keyword">*</span> &#125;]</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">addParents = function(_data) &#123;</span><br><span class="line">	//具体实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u6DFB_u52A0_u5B50_u7EA7_u83DC_u5355"><a href="#u6DFB_u52A0_u5B50_u7EA7_u83DC_u5355" class="headerlink" title="添加子级菜单"></a>添加子级菜单</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    <span class="keyword">*</span> [addChild 添加子级菜单]</span><br><span class="line">    <span class="keyword">*</span> <span class="comment">@param &#123;[Array]&#125; _data [菜单数据]</span></span><br><span class="line">    <span class="keyword">*</span> [&#123;</span><br><span class="line">    <span class="keyword">*</span> 		id: 菜单id,</span><br><span class="line">    <span class="keyword">*</span> 		name: 菜单显示值,</span><br><span class="line">    <span class="keyword">*</span> 		pId: 父级菜单id</span><br><span class="line">    <span class="keyword">*</span> &#125;]</span><br><span class="line">    <span class="keyword">*</span>/</span><br><span class="line">   addChild = function(_data) &#123;</span><br><span class="line">   	  //具体实现</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u6DFB_u52A0_u65E0_u5B50_u7EA7_u7684_u83DC_u5355"><a href="#u6DFB_u52A0_u65E0_u5B50_u7EA7_u7684_u83DC_u5355" class="headerlink" title="添加无子级的菜单"></a>添加无子级的菜单</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    <span class="keyword">*</span> [addChildNode 添加无子级子级菜单]</span><br><span class="line">    <span class="keyword">*</span> <span class="comment">@param &#123;[Array]&#125; _data [菜单数据]</span></span><br><span class="line">    <span class="keyword">*</span> [&#123;</span><br><span class="line">    <span class="keyword">*</span> 		id: 菜单id,</span><br><span class="line">    <span class="keyword">*</span> 		name: 菜单显示值,</span><br><span class="line">    <span class="keyword">*</span> 		pId: 父级菜单id</span><br><span class="line">    <span class="keyword">*</span> &#125;]</span><br><span class="line">    <span class="keyword">*</span>/</span><br><span class="line">    addChildNode = function(_data) &#123;</span><br><span class="line">    	  //具体实现</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="demo_u5C55_u793A"><a href="#demo_u5C55_u793A" class="headerlink" title="demo展示"></a>demo展示</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">title</span>&gt;</span>Treeview Plugin Demo<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"./css/js-treeview-plugin.css"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">		<span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">			<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">			<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">			<span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">		&#125;</span></span><br><span class="line">		<span class="class">.treeviewCont</span> <span class="rules">&#123;</span><br><span class="line">			<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">			<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">			<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>;</span><br><span class="line">			<span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">		&#125;</span></span><br><span class="line">		</span><br><span class="line">	</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">h1</span>&gt;</span>Treeview Plugin Demo<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"treeviewCont"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">		$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> tree = $(<span class="string">'.treeviewCont'</span>);</span><br><span class="line">			treeViewPlugin.initModule(tree);</span><br><span class="line">			treeViewPlugin.addParents([</span><br><span class="line">	                &#123;</span><br><span class="line">	                    name: <span class="string">'Betty'</span>,</span><br><span class="line">	                    id: <span class="string">'id_01'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    name: <span class="string">'Mike'</span>,</span><br><span class="line">	                    id: <span class="string">'id_02'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    name: <span class="string">'Pebbles'</span>,</span><br><span class="line">	                    id: <span class="string">'id_03'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    name: <span class="string">'Wilma'</span>,</span><br><span class="line">	                    id: <span class="string">'id_04'</span></span><br><span class="line">	                &#125;</span><br><span class="line">	            ]);</span><br><span class="line">	            treeViewPlugin.addChild([</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_01'</span>,</span><br><span class="line">	                    name: <span class="string">'Betty'</span>,</span><br><span class="line">	                    id: <span class="string">'id_01_01'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_01'</span>,</span><br><span class="line">	                    name: <span class="string">'Mike'</span>,</span><br><span class="line">	                    id: <span class="string">'id_01_02'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_03'</span>,</span><br><span class="line">	                    name: <span class="string">'Pebbles'</span>,</span><br><span class="line">	                    id: <span class="string">'id_03_01'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_04'</span>,</span><br><span class="line">	                    name: <span class="string">'Wilma'</span>,</span><br><span class="line">	                    id: <span class="string">'id_04_01'</span></span><br><span class="line">	                &#125;</span><br><span class="line">	            ]);</span><br><span class="line">	            treeViewPlugin.addChildNode([</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_01'</span>,</span><br><span class="line">	                    name: <span class="string">'Btrey'</span>,</span><br><span class="line">	                    id: <span class="string">'id_01_001'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_01'</span>,</span><br><span class="line">	                    name: <span class="string">'Hans'</span>,</span><br><span class="line">	                    id: <span class="string">'id_01_002'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_03'</span>,</span><br><span class="line">	                    name: <span class="string">'wekous'</span>,</span><br><span class="line">	                    id: <span class="string">'id_03_001'</span></span><br><span class="line">	                &#125;,</span><br><span class="line">	                &#123;</span><br><span class="line">	                    pId: <span class="string">'id_04'</span>,</span><br><span class="line">	                    name: <span class="string">'Wimaka'</span>,</span><br><span class="line">	                    id: <span class="string">'id_04_001'</span></span><br><span class="line">	                &#125;</span><br><span class="line">	            ]);</span><br><span class="line">		&#125;);</span><br><span class="line">	</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>此插件只是初步实现，更多功能待完善，实际使用可根据实际需求做相应修改，欢迎大家一起分享、交流、学习。</strong></p>
<p><em><a href="https://github.com/codingplayboy/javascriptDemo/tree/master/treeViewPlugin" target="_blank" rel="external">查看插件源码点此</a>
</em></p>
]]></content>
    <summary type="html">
    <![CDATA[treeViewPlugin，一个可以生成任意多级树列表的js插件，使用了jquery事件委托处理跨浏览器添加事件监听及DOM操作实现需求。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://blog.codingplayboy.com/tags/jQuery/"/>
    
      <category term="插件" scheme="http://blog.codingplayboy.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
      <category term="jQuery" scheme="http://blog.codingplayboy.com/categories/JavaScript/jQuery/"/>
    
      <category term="插件" scheme="http://blog.codingplayboy.com/categories/JavaScript/jQuery/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之this、call与apply]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/07/js-executionContext/"/>
    <id>http://blog.codingplayboy.com/2016/01/07/js-executionContext/</id>
    <published>2016-01-06T16:26:50.000Z</published>
    <updated>2016-01-06T16:42:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4Bthis_u3001call_u4E0Eapply"><a href="#JavaScript_u4E4Bthis_u3001call_u4E0Eapply" class="headerlink" title="JavaScript之this、call与apply"></a>JavaScript之this、call与apply</h1><p>在JavaScript学习中，this的重要性不明而寓，有必要对其深入学习，而与this息息相关的有两个特别需要注意的就是call，apply，本篇就着手从this开始阐述，而后介绍call、apply之用法。</p>
<blockquote>
<p>调用一个函数时代码执行控制权就转移到此函数，同时将参数传入此函数，除了声明函数时定义的形式参数，每个函数都会接受两个附加参数：this和arguments。</p>
</blockquote>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><strong>JavaScript中this总是指向一个对象，这个对象基于函数运行时的执行环境动态绑定，而非函数声明时所处环境。</strong></p>
<p><em><a href="http://blog.codingplayboy.com/2016/01/07/js-scope/">关于执行环境可查看本系列篇JavaScript之作用域与作用域链</a></em></p>
<h3 id="this_u6307_u5411"><a href="#this_u6307_u5411" class="headerlink" title="this指向"></a>this指向</h3><p>关于this指向问题，与函数调用息息相关，其可大致分为四类情况：</p>
<ul>
<li>(1). 方法调用； 即作为某对象的方法调用。</li>
<li>(2). 函数调用；即作为普通函数调用。</li>
<li>(3). 构造器函数调用；即以new方式调用。</li>
<li>(4). call与apply调用；即以Function.prototype.call或Function.prototype.apply调用。</li>
</ul>
<h4 id="u65B9_u6CD5_u8C03_u7528"><a href="#u65B9_u6CD5_u8C03_u7528" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === obj); <span class="comment">//输出true</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//输出Job</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>
<p><strong>当函数作为对象的方法被调用时，this总是指向该对象。</strong></p>
<h4 id="u51FD_u6570_u8C03_u7528"><a href="#u51FD_u6570_u8C03_u7528" class="headerlink" title="函数调用"></a>函数调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Job'</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">//输出true</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//输出Job</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">getName(); <span class="comment">//普通函数调用</span></span><br></pre></td></tr></table></figure>
<p><strong>非严格模式下，当函数作为普通函数方式调用时，不论该函数调用时所处执行环境为何，this总是指向全局对象，JavaScript中即是window对象。</strong></p>
<p>再看如下实例，加深理解：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> id = <span class="string">'windowId'</span>;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">//输出myDiv</span></span><br><span class="line">		<span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">//输出windowId</span></span><br><span class="line">		&#125;;</span><br><span class="line">		fn(); <span class="comment">//普通函数调用</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u6784_u9020_u5668_u51FD_u6570_u8C03_u7528"><a href="#u6784_u9020_u5668_u51FD_u6570_u8C03_u7528" class="headerlink" title="构造器函数调用"></a>构造器函数调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.name); <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p><strong>当用new调用构造器函数时，总会返回一个对象，该对象可以看成是构造器函数一个实例，一般，此时构造器里的this就指向返回的这个对象。</strong><br>但还需要注意的是当构造器显式地返回一个对象时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name: <span class="string">'Job'</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.name); <span class="comment">//输出Job</span></span><br></pre></td></tr></table></figure></p>
<p>此时，this指向的是构造器显式返回的对象。</p>
<h4 id="call_u4E0Eapply_u8C03_u7528"><a href="#call_u4E0Eapply_u8C03_u7528" class="headerlink" title="call与apply调用"></a>call与apply调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === obj); </span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">'Web'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName());  <span class="comment">//输出Job</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName.call(obj2)); <span class="comment">//输出Web</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName.apply(obj2)); <span class="comment">//输出Web</span></span><br></pre></td></tr></table></figure>
<p>当以Function.prototype.call或Function.prototype.apply方式调用函数时，动态传入参数改变执行环境，此时this指向传入的对象。</p>
<h2 id="call_u4E0Eapply"><a href="#call_u4E0Eapply" class="headerlink" title="call与apply"></a>call与apply</h2><p>call与apply是Function原型上定义的两个方法，其应用广泛。</p>
<h3 id="call_u4E0Eapply_u7684_u533A_u522B"><a href="#call_u4E0Eapply_u7684_u533A_u522B" class="headerlink" title="call与apply的区别"></a>call与apply的区别</h3><p>两者作用完全一样，不同之处在于传入参数的形式。</p>
<blockquote>
<p>call传入参数数量不固定，第一个参数代表所调用函数体内this的指向，而后依次为所调用函数所需参数。</p>
<p>apply接受最多两个参数，第一个参数指定被调用函数内this的指向，第二个参数为一个带下标的集合，可以是数组或者类数组，作为参数传给被调用函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var fn = function(a, b, b) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>([a, b, c]);</span><br><span class="line">&#125;;</span><br><span class="line">fn.call(null, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">fn.apply(null, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，非严格模式下，使用call或apply时，第一个参数是必须的，当第一个参数传入null时，函数体内this就会指向被调用函数的宿主对象(其包含对象)；而严格模式下，this指向则为null</strong></p>
<h3 id="call_u4E0Eapply_u7684_u5E94_u7528"><a href="#call_u4E0Eapply_u7684_u5E94_u7528" class="headerlink" title="call与apply的应用"></a>call与apply的应用</h3><h4 id="u6539_u53D8this_u6307_u5411"><a href="#u6539_u53D8this_u6307_u5411" class="headerlink" title="改变this指向"></a>改变this指向</h4><p>使用call或apply调用函数可改变函数体内this的指向。实例如前文中this指向相关实例。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h4><p>Function.prototype.bind可以用来绑定函数体内this指向，其参数为this的指向对象。IE8及以下不支持，这里我们可以自己实现一个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;  <span class="comment">//保存原函数的引用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//返回一个新函数</span></span><br><span class="line">		<span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>); <span class="comment">//将传入的参数指定为新函数体内this的指向对象</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'Job'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">fn.bind(obj)();</span><br></pre></td></tr></table></figure></p>
<h4 id="u501F_u7528_u5176_u4ED6_u5BF9_u8C61_u7684_u65B9_u6CD5"><a href="#u501F_u7528_u5176_u4ED6_u5BF9_u8C61_u7684_u65B9_u6CD5" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h4><p>最熟悉的就是借用构造函数实现类似继承的效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Dog.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.getName());  <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure></p>
<p>另一很常见的情况就是借用Array.prototype对象上的方法处理函数参数类数组arguments:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); <span class="comment">//arguments为类数组[1,2,3]</span></span><br><span class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>); <span class="comment">//将arguments类数组剩余参数转换为数组赋给args变量</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//输出[2, 3]</span></span><br><span class="line">	<span class="built_in">console</span>.log(args); <span class="comment">//输出[2, 3]</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面借用Array.prototype上的shift方法移除参数列表的首位，当然也可以借用其他方法达到其他目的，如push, slice等。</p>
<p>JavaScript中，call与apply的应用是非常广泛的，在各类Js框架库中，都不难发现其身影。</p>
]]></content>
    <summary type="html">
    <![CDATA[在JavaScript学习中，this的重要性不明而寓，有必要对其深入学习，而与this息息相关的有两个特别需要注意的就是call，apply，本篇就着手从this开始阐述，而后介绍call、apply之用法。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="this" scheme="http://blog.codingplayboy.com/tags/this/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之作用域与作用域链]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/07/js-scope/"/>
    <id>http://blog.codingplayboy.com/2016/01/07/js-scope/</id>
    <published>2016-01-06T16:11:48.000Z</published>
    <updated>2016-01-06T16:23:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE"><a href="#JavaScript_u4E4B_u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="JavaScript之作用域与作用域链"></a>JavaScript之作用域与作用域链</h1><p>此篇阐述JavaScript中很重要的几个概念：作用域与作用域链及相关知识点，首先从变量与作用域的行为关系开始讨论。</p>
<h2 id="u53D8_u91CF_u4F5C_u7528_u57DF"><a href="#u53D8_u91CF_u4F5C_u7528_u57DF" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>JavaScript中，变量有全局变量及局部变量之分，而能定义变量作用域的语块只有函数。与局部变量有关的一种有趣特性，在此处不得不谈–变量提升。</p>
<h3 id="u53D8_u91CF_u63D0_u5347"><a href="#u53D8_u91CF_u63D0_u5347" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量提升为何物？</p>
<blockquote>
<p>JavaScript的变量声明会被提升到它们所在函数的顶部，而初始化仍旧在原来的地方。JavaScript引擎并没有重写代码：每次调用函数时，声明都会重新提升。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jog'</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prison</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>；<span class="comment">//局部变量</span></span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//输出1</span></span><br><span class="line">	<span class="built_in">console</span>.log(name); <span class="comment">//输出Jog</span></span><br><span class="line">&#125;</span><br><span class="line">prison();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jog'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prison</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Hans'</span>;</span><br><span class="line">&#125;</span><br><span class="line">prison();</span><br></pre></td></tr></table></figure>
<p><strong>此处name的声明被提升到函数的顶部，变量查找时先从局部作用域开始，未找到则由内而外最后到全局作用域。</strong></p>
<p>接下来我们详细分析一下JavaScript的提升方式。</p>
<h3 id="u53D8_u91CF_u63D0_u5347_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61"><a href="#u53D8_u91CF_u63D0_u5347_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61" class="headerlink" title="变量提升与执行环境对象"></a>变量提升与执行环境对象</h3><p>学习任何一门语言，都像学习魔术一样，初时引人迷惑，惊叹；然而当秘密被揭开时几乎令人失望，JavaScript不外如是。</p>
<h4 id="u63D0_u5347"><a href="#u63D0_u5347" class="headerlink" title="提升"></a>提升</h4><p>执行某代码块时，JavaScript引擎先解释，再运行。解释过程主要几个过程：</p>
<pre><code>- (1) 声明该作用域内var变量
- (2) 声明并初始化函数参数
- (3) 声明并初始化声明式函数
</code></pre><p><em><a href="https://github.com/codingplayboy/javascript_notes/blob/master/js_compileRun.md" target="_blank" rel="external">详细可查看本系列笔记JavaScript之解释与执行机制</a></em></p>
<h4 id="u6267_u884C_u73AF_u5883_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61"><a href="#u6267_u884C_u73AF_u5883_u4E0E_u6267_u884C_u73AF_u5883_u5BF9_u8C61" class="headerlink" title="执行环境与执行环境对象"></a>执行环境与执行环境对象</h4><p><strong>执行环境（execution context）</strong>是一种概念，每当函数被调用都会产生一个新的执行环境。</p>
<blockquote>
<p><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
</blockquote>
<pre><code>- 1. 每个函数都有自己的执行环境。  当执行流进入一个函数时，执行环境就被推入一个环境栈中；函数执行之后，栈将其执行环境弹出，控制权返回到之前的执行环境。
- 2. 如果变量在当前执行环境内可访问，则该变量在当前作用域内。
- 3. JavaScript访问变量，其实就是访问该执行环境对象（变量对象）中的属性。
- 4. 全局执行环境是最外围的一个执行环境。
</code></pre><blockquote>
<p><strong>执行环境对象</strong>–每个执行环境都有一个与之对应的<strong>变量对象</strong>，执行环境中定义的所有变量和函数都保存在这个对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Far'</span>;</span><br><span class="line">	inner();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'inner'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<p>在调用fn时，其过程如下</p>
<pre><code>- 1. 创建一个空执行环境对象；
- 2. 声明参数并赋值；{arg: 1}
- 3. 声明局部变量；{arg:1, name: undefined}
- 4. 预定义声明式函数；{arg:1, name: undefined， inner: function(){console.log(&apos;inner&apos;);}}
- 5. 代码执行时，局部变量被赋值；{...name: &apos;Far&apos;...}
- 6. 执行环境对象上变量和函数属性保持不变，调用inner函数时，其内部会创建一个新的执行环境对象，依此可递归形成一条作用域链。
</code></pre><h2 id="u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE"><a href="#u4F5C_u7528_u57DF_u4E0E_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><blockquote>
<p>当一个变量在某执行回家内可以被访问，我们称该变量在当前<strong>作用域</strong>内。</p>
</blockquote>
<p>代码某一执行环境中执行时，会创建该<strong>执行环境对应的变量对象</strong>的一个作用域链。</p>
<blockquote>
<p>JavaScript引擎在执行环境对象中查找作用域内的变量或函数，其查找顺序由内而外向上直到全局执行环境对象，这个顺序就形成<strong>作用域链</strong>。</p>
</blockquote>
<p>作用域链的<strong>前端</strong>，始终是当前执行环境对应的变量对象。若此执行环境是函数，则将其活动对象作为变量对象。作用域链中的<strong>下一个</strong>变量对象来自于当前变量对象的包含（外部）执行环境，如此一直到全局执行环境；全局执行环境的变量对象始终是作用域链中的<strong>最后</strong>一个变量对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> country = <span class="string">'China'</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Java'</span>;</span><br><span class="line"><span class="keyword">var</span> job = <span class="string">'Web'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(age);  <span class="comment">//输出22</span></span><br><span class="line">	<span class="built_in">console</span>.log(country); <span class="comment">//输出undefined</span></span><br><span class="line">	<span class="keyword">var</span> country = <span class="string">'Union'</span>;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'Python'</span>;</span><br><span class="line">	inner();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name); <span class="comment">//输出Python</span></span><br><span class="line">		<span class="built_in">console</span>.log(job); <span class="comment">//输出Web</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>代码输出结果如上：</p>
<pre><code>- 1. outer函数执行时，首先在outer执行环境对象中查找age和country变量结果country存在但并未初始化赋值，输出undefined;而age未找到于是沿着作用域链向上到全局执行环境，在其变量对象中存在age属性，于是输出其值22.
- 2. inner函数执行时创建自己的执行环境对象，其并没有定义name和job等变量，于是沿着作用域链向上到达outer函数的执行环境，在其变量对象中存在name于是输出其值Python；而未找到job于是继续向上直到全局执行环境，找到并输出其值，结束；若依然未找到，则会报错，停止运行。
</code></pre><p><strong>注：函数参数亦被当作变量对待，故其访问规则与普通变量相同。</strong></p>
<h3 id="u5EF6_u957F_u4F5C_u7528_u57DF_u94FE"><a href="#u5EF6_u957F_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>某些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行结束后移除。常见如：</p>
<ul>
<li>try-catch语句；<br>catch语句会创建一个新变量对象，包含被抛出的错误对象的声明。</li>
<li>with语句；<br>with语句会创建一个包含语句接收对象的所有属性和方法的变量对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAttr</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = data;</span><br><span class="line">	<span class="keyword">with</span>(obj) &#123;</span><br><span class="line">		<span class="keyword">var</span> o = location;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(o);</span><br><span class="line">&#125;</span><br><span class="line">getAttr(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>上面with语句接收window对象，其创建的变量对象就包含了window对象所有属性和方法，于是可以在其执行环节直接访问location变量，也就是正常的window.location。</p>
<p><em>强烈建议不要使用with语句。</em></p>
<p>本篇笔记阐述JavaScript执行环境与执行环境对象，变量对象，作用域与作用域链，耗时颇多，还有诸多不足之处待日后补充改进。</p>
]]></content>
    <summary type="html">
    <![CDATA[在JavaScript的进阶学习过程中，深入理解其作用域与作用域链必不可少，本篇主要阐述JavaScript执行环境与执行环境对象，变量对象，作用域与作用域链及其关系。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Scope" scheme="http://blog.codingplayboy.com/tags/Scope/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之原型与原型链]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-prototype/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-prototype/</id>
    <published>2016-01-06T13:44:22.000Z</published>
    <updated>2016-01-06T13:50:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE"><a href="#JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE" class="headerlink" title="JavaScript之原型与原型链"></a>JavaScript之原型与原型链</h1><p>在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。</p>
<h2 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h2><p>Javascript中创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的作用即是包含可以由特定类型实例共享的属性和方法，这个对象就是函数的原型对象。</p>
<p>默认情况，所有的原型对象都会有一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>调用构造函数创建一个新实例后，实例的内部将包含一个指向构造函数原型对象的指针，在ECMA-262中定义此指针为[[Prototype]]，并不能被显式的访问到，而在Firefox,Safari和Chrome中每个对象上有一个__proto__属性。</p>
<p><em>__proto__显示的是实例与构造函数原型对象间的关系，而非实例与构造函数间的关系。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.getName());  <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，Animal为构造函数，Animal.prototype指向构造函数原型对象；原型对象中constructor属性指向构造函数，即Animal.prototype.constructor指向Animal；在构造函数实例中，其__proto__属性指向构造函数原型对象。</p>
<h3 id="u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE"><a href="#u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE" class="headerlink" title="原型与实例属性访问"></a>原型与实例属性访问</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line">animal2.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出4--实例属性</span></span><br><span class="line"><span class="keyword">delete</span> animal2.age;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取某对象属性时，首先从该对象实例本身开始，若该实例中找到该属性，则返回该属性值；若未找到，则继续查找该实例对象指向的构造函数原型对象，若找到则返回值。</p>
</blockquote>
<p>(1) hasOwnProperty()方法<br>hasOwnProperty()方法可以检测一个属性是在原型上还是实例上，只有当给定属性为对象实例属性时返回true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line">animal1.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>(2) 原型与in<br>单独使用in操作符时，只要通过对象能访问到给定属性即返回true，无论属性是在实例还是原型上定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'eat'</span> <span class="keyword">in</span> animal1); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB"><a href="#u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB" class="headerlink" title="实例与原型的引用关系"></a>实例与原型的引用关系</h3><p>实例在创建时，其内部指针[[Prototype]](在上文提到的__proto__)指向构造函数原型对象，存在引用关系。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">animal.getName(); <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然实例早于原型中getName方法创建，但其依然可以调用该方法，因为实例通过引用指向原型对象，原型对象变化自然能被实例访问到。然而，对于如下这种情况：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: Animal,  //设置<span class="keyword">constructor</span>值为Animal，确保<span class="keyword">constructor</span>属性返回适当值，详细见上文关于<span class="keyword">constructor</span>属性说明</span><br><span class="line">	age: 3,</span><br><span class="line">	getName: function() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal2.getName());  <span class="comment">//输出Cat</span></span><br><span class="line">animal.getName();  <span class="comment">//TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>此处，首先创建了一个实例，随后重写了构造函数原型对象，再在实例上调用getName方法时报错；而重写构造函数原型对象之后创建的实例调用getName方法可以正常返回对应值。这是因为重写原型对象之后，之前创建的实例引用的依然是之前的原型对象，其与现有原型之间并无联系，而之后创建的实例[[Prototype]]指针引用的就是现有原型。</p>
<h3 id="u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898"><a href="#u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898" class="headerlink" title="原型对象存在问题"></a>原型对象存在问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.partner = [<span class="string">'one'</span>];</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one"] </span></span><br><span class="line">animal1.partner.push(<span class="string">'two'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner === animal2.partner); <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure>
<p>可以看到原型中所有属性都被实例共享，特别是对于引用类型的属性，如上的partner属性。</p>
<h3 id="u9ED8_u8BA4_u539F_u578B"><a href="#u9ED8_u8BA4_u539F_u578B" class="headerlink" title="默认原型"></a>默认原型</h3><p>所有引用类型默认都继承自Object，所有构造函数默认原型都是Object的实例，默认原型都会包含一个内部指针，指向Object.prototype。</p>
<h3 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB" class="headerlink" title="构造函数，原型与实例的关系"></a>构造函数，原型与实例的关系</h3><p>每个构造函数都有一个原型对象，由prototype属性指向；原型对象包含一个指向构造函数的指针constructor；而实例都包含一个指向构造函数原型对象的内部指针[[Prototype]]。</p>
<h2 id="u539F_u578B_u94FE"><a href="#u539F_u578B_u94FE" class="headerlink" title="原型链"></a>原型链</h2><p>每一个构造函数都有一个原型对象，当我们让某一原型对象等于另一构造函数的实例，此时该原型对象就包含一个指针，该指针指向这一构造函数的原型对象，该指针指向的原型对象中包含一个指向这一构造函数的指针，同样我们可以令该指针指向的原型对象等于另一构造函数的实例，如此递进，则形成一条实例与原型的链条，即原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.childname = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.getChildName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.childname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getName()); <span class="comment">//输出parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getChildName());  <span class="comment">//输出child</span></span><br></pre></td></tr></table></figure>
<p>如上代码，child实例指向Child原型，Child原型等于Parent实例，即指向Parent原型。可见本质即是以一个新类型（构造函数）的实例重写原型对象，形成原型链。</p>
<h3 id="u539F_u578B_u94FE_u95EE_u9898"><a href="#u539F_u578B_u94FE_u95EE_u9898" class="headerlink" title="原型链问题"></a>原型链问题</h3><p>既然原型对象存在问题，那么原型链自然也继承了这个问题，即原型属性会被所有实例共享，对于原型属性的改变将影响所有实例，而在原型链中，由于某一原型对象等于另一构造函数的实例，实例受影响，也就导致其他原型对象也受影响。</p>
<p>原型与原型链是JavaScript实现继承的基础，下一篇详细介绍JavaScript之继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Prototype" scheme="http://blog.codingplayboy.com/tags/Prototype/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之解释与执行机制]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-compileRun/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-compileRun/</id>
    <published>2016-01-06T13:09:50.000Z</published>
    <updated>2016-01-06T13:19:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236"><a href="#JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236" class="headerlink" title="JavaScript之解释与执行机制"></a>JavaScript之解释与执行机制</h1><p>不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。</p>
<blockquote>
<p>解释型语言：程序不需要编译，程序在运行时才<strong>翻译</strong>成机器语言，每执行一次都要翻译一次。</p>
<p>编译型语言：程序在执行之前需要一个专门的<strong>编译</strong>过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果。</p>
</blockquote>
<p><em>JavaScript翻译过程又做解释过程。</em></p>
<h2 id="JavaScript_u89E3_u91CA_u4E0E_u6267_u884C"><a href="#JavaScript_u89E3_u91CA_u4E0E_u6267_u884C" class="headerlink" title="JavaScript解释与执行"></a>JavaScript解释与执行</h2><p>JavaScript按照代码块来进行解释和执行，代码块间相互独立，但变量和方法共享。</p>
<blockquote>
<p>JavaScript中的代码块是指由<code>&lt;script&gt;&lt;/script&gt;</code>标签分割的代码段。</p>
</blockquote>
<h3 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h3><p>JavaScript代码块在执行时先由解释器进行解释，主要过程是声明所有var变量（并未初始化赋值，当前值为undefined）、解析<strong>声明式</strong>函数语句，而且是先预定义变量再预定义函数。</p>
<blockquote>
<p>JavaScript中函数定义主要主要有两种：声明式与函数表达式。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u7801_u5206_u6790"><a href="#u4EE3_u7801_u5206_u6790" class="headerlink" title="代码分析"></a>代码分析</h3><ol>
<li><strong>试分析以下代码：</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">var a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>弹出undefined和ok。因为执行时先解释：1.定义var变量，并未初始化赋值，当前值为undefined。</p>
<ol>
<li><strong>请君细看</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>会发现报错了，因为a未定义，解释时定义var变量，并不会定义此处的a。</p>
<p>到这里我们又发现了一个值得关注的问题–定义变量的方式。</p>
<blockquote>
<p>JavaScript变量分两种：全局变量和局部变量。像a = 1;这种定义默认是创建全局变量，其实就相当于window.a = 1;而var a = 1;这种格式是定义一个当前作用域下的变量。解释时只会定义var格式的变量。</p>
</blockquote>
<p>3.<strong>函数相关</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"函数表达式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok1'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"声明式函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok2'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如何呢？运行上述代码你会发现弹出了“声明式函数”和“ok2”。<br>为什么呢，这里就涉及到前面所说的<strong>代码块之间是相互独立的</strong>，故前面的a()虽然报错了，阻塞了ok1弹出；但是第二段script代码并不受影响。</p>
<p>第一段代码缘何报错？因为代码执行时先解释声明式函数而不会解释函数表达式，此时只是定义了a变量，未初始化，其值为undefined,不是函数。</p>
<p>到此时对JavaScript的解释与执行机制、顺序也算有初步的认识了。</p>
]]></content>
    <summary type="html">
    <![CDATA[不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。]]>
    
    </summary>
    
      <category term="Compile" scheme="http://blog.codingplayboy.com/tags/Compile/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之面向对象]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-object/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-object/</id>
    <published>2016-01-05T16:16:11.000Z</published>
    <updated>2016-01-06T13:12:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61"><a href="#JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61" class="headerlink" title="JavaScript之面向对象"></a>JavaScript之面向对象</h1><p>传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。</p>
<h2 id="u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B"><a href="#u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>何谓动态，何谓静态？编程语言按数据类型大体分为两类：动态类型语言，静态类型语言。</p>
<blockquote>
<p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行时，待变量被赋值后，才会具有某种类型。</p>
</blockquote>
<p>典型的静态类型语言有Java, C#等，而在JavaScript中，当我们为某变量赋值时，并不需要判断其类型，其显然是一门典型的动态类型语言。</p>
<h2 id="JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE"><a href="#JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE" class="headerlink" title="JavaScript对象和原型链"></a>JavaScript对象和原型链</h2><h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>与对象最紧密相关当然是变量了<br>JavaScript的中有五种简单数据类型（也称基本数据类型）以及一种复杂数据类型。<br>简单数据类型包括数字, 字符串, 布尔值（true和false）, null, undefined值。<br>复杂数据类型即Object。<strong>JavaScript中除了简单数据类型值，其他所有值均为对象。</strong></p>
<h4 id="JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C"><a href="#JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C" class="headerlink" title="JavaScript变量之基本类型值与引用类型值"></a>JavaScript变量之基本类型值与引用类型值</h4><p>JavaScript变量可能包含两种不同数据类型的值：基本数据类型值和引用类型值。将一个值赋给变量时，解析器会判断这个值的类型。</p>
<blockquote>
<p>基本类型值指的是简单的数据段，是按值访问的，可以操作保存在变量中的实际值；而引用类型值指那些可能由多个值构成的对象，是引用类型的一个实例，是按引用访问的。</p>
</blockquote>
<ul>
<li><strong>基本类型</strong> 即包括如前所述的五种。</li>
<li><strong>引用类型</strong> 一种数据结构，用以描述对象的属性和方法。</li>
</ul>
<p><em>注：引用类型值和引用类型不同。</em></p>
<p>JavaScript引用类型主要包括Object，Array，Date，RegExp，Function以及为了操作基本类型值提供的三个特殊引用类型：Boolean，Number和String。<strong>可以说，JavaScript中对象即是某种引用类型的实例，我们使用的大多数引用类型值又都是Object类型的实例。</strong></p>
<h3 id="JavaScript_u521B_u5EFA_u5BF9_u8C61"><a href="#JavaScript_u521B_u5EFA_u5BF9_u8C61" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h3><p>不同于许多传统面向对象语言使用基于类的对象，JavaScript使用基于原型的对象。</p>
<ul>
<li><strong>对象字面量</strong> 一个对象字面量就是在一对花括号中的零或多个名值对。</li>
<li><strong>Object构造函数</strong> 调用Object构造函数，可使用new Object()形式创建对象。<em>Object.create()方式创建对象亦很常见。</em></li>
</ul>
<h3 id="JavaScript_u7EE7_u627F"><a href="#JavaScript_u7EE7_u627F" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h3><p>继承（Object Orient）向来是面向对象语言最突出特征之一，如Java等传统OO语言都支持基于类的继承，而JavaScript中是没有类的概念，其主要依靠原型链实现继承。</p>
<blockquote>
<p>基于原型链的委托机制就是原型继承的本质，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<h4 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h4><p>对象的原型，就JavaScript真正实现而言，其实对象并无原型，而是对象的构造器（构造函数）与原型。所谓‘对象把请求委托给自己的原型’即是把请求委托给其构造器原型。JavaScript对象的__proto__属性默认即指向其构造器原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B" class="headerlink" title="构造函数，原型与实例"></a>构造函数，原型与实例</h4><p><strong>每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而构造函数的实例都包含一个指向原型对象的内部指针。JavaScript中所有对象都默认继承自根对象Object。</strong></p>
<p>给一个构造函数的原型对象赋值为另一个类型的实例，此时原型对象即包含指向另一原型对象的指针，而另一个原型对象中也包含指向其相应构造函数的指针，如此便构成了原型与实例的关系链，也即原型链。依此可实现不同对象间的属性和方法的继承。</p>
<ul>
<li><strong>默认原型</strong> 所有引用类型默认都继承了Object，所有函数的默认原型都是Object实例，而如前所述：构造函数的实例都包含一个指向原型对象的内部指针，因此默认原型都包含一个指向Object.prototype（即Object原型）的内部指针。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="string">'Animal'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getAnimalProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">this</span>.dogproperty = <span class="string">'Dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承自Animal</span></span><br><span class="line">Dog.prottotype.getDogProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>. dogproperty; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">alert(dog.getDogProperty);</span><br><span class="line">alert(dog.getAnimalProperty);</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>对象的根对象</strong> JavaScript对象都源于（继承自）根对象Object。</li>
<li><strong>对象源自克隆</strong> 定义对象，不是通过实例化类，而是把另一对象作为原型并克隆之。</li>
<li><strong>对象记忆性</strong> 请求可以在原型链中依此向后传递，每个对象都会记住自己的原型，详细请回顾上文关于对象原型之说的__proto__属性。</li>
<li><strong>对象请求传递性</strong> 若当前对象无法响应当前请求，便将其委托给其构造器原型。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Object Oriented" scheme="http://blog.codingplayboy.com/tags/Object-Oriented/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/04/hello-world/"/>
    <id>http://blog.codingplayboy.com/2016/01/04/hello-world/</id>
    <published>2016-01-03T16:16:11.000Z</published>
    <updated>2016-01-06T13:32:25.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on GitHub.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/categories/Hexo/"/>
    
  </entry>
  
</feed>

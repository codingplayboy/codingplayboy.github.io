<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[惊鸿三世的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.codingplayboy.com/"/>
  <updated>2016-01-06T13:50:43.000Z</updated>
  <id>http://blog.codingplayboy.com/</id>
  
  <author>
    <name><![CDATA[惊鸿三世]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript之原型与原型链]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-prototype/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-prototype/</id>
    <published>2016-01-06T13:44:22.000Z</published>
    <updated>2016-01-06T13:50:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE"><a href="#JavaScript_u4E4B_u539F_u578B_u4E0E_u539F_u578B_u94FE" class="headerlink" title="JavaScript之原型与原型链"></a>JavaScript之原型与原型链</h1><p>在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。</p>
<h2 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h2><p>Javascript中创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的作用即是包含可以由特定类型实例共享的属性和方法，这个对象就是函数的原型对象。</p>
<p>默认情况，所有的原型对象都会有一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>调用构造函数创建一个新实例后，实例的内部将包含一个指向构造函数原型对象的指针，在ECMA-262中定义此指针为[[Prototype]]，并不能被显式的访问到，而在Firefox,Safari和Chrome中每个对象上有一个__proto__属性。</p>
<p><em>__proto__显示的是实例与构造函数原型对象间的关系，而非实例与构造函数间的关系。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.getName());  <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，Animal为构造函数，Animal.prototype指向构造函数原型对象；原型对象中constructor属性指向构造函数，即Animal.prototype.constructor指向Animal；在构造函数实例中，其__proto__属性指向构造函数原型对象。</p>
<h3 id="u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE"><a href="#u539F_u578B_u4E0E_u5B9E_u4F8B_u5C5E_u6027_u8BBF_u95EE" class="headerlink" title="原型与实例属性访问"></a>原型与实例属性访问</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br><span class="line">animal2.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出4--实例属性</span></span><br><span class="line"><span class="keyword">delete</span> animal2.age;</span><br><span class="line"><span class="built_in">console</span>.log(animal2.age); <span class="comment">//输出3--原型属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取某对象属性时，首先从该对象实例本身开始，若该实例中找到该属性，则返回该属性值；若未找到，则继续查找该实例对象指向的构造函数原型对象，若找到则返回值。</p>
</blockquote>
<p>(1) hasOwnProperty()方法<br>hasOwnProperty()方法可以检测一个属性是在原型上还是实例上，只有当给定属性为对象实例属性时返回true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line">animal1.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>(2) 原型与in<br>单独使用in操作符时，只要通过对象能访问到给定属性即返回true，无论属性是在实例还是原型上定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.hasOwnProperty(<span class="string">'age'</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> animal1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'eat'</span> <span class="keyword">in</span> animal1); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB"><a href="#u5B9E_u4F8B_u4E0E_u539F_u578B_u7684_u5F15_u7528_u5173_u7CFB" class="headerlink" title="实例与原型的引用关系"></a>实例与原型的引用关系</h3><p>实例在创建时，其内部指针[[Prototype]](在上文提到的__proto__)指向构造函数原型对象，存在引用关系。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">animal.getName(); <span class="comment">//输出Dog</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然实例早于原型中getName方法创建，但其依然可以调用该方法，因为实例通过引用指向原型对象，原型对象变化自然能被实例访问到。然而，对于如下这种情况：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: Animal,  //设置<span class="keyword">constructor</span>值为Animal，确保<span class="keyword">constructor</span>属性返回适当值，详细见上文关于<span class="keyword">constructor</span>属性说明</span><br><span class="line">	age: 3,</span><br><span class="line">	getName: function() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal2.getName());  <span class="comment">//输出Cat</span></span><br><span class="line">animal.getName();  <span class="comment">//TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>此处，首先创建了一个实例，随后重写了构造函数原型对象，再在实例上调用getName方法时报错；而重写构造函数原型对象之后创建的实例调用getName方法可以正常返回对应值。这是因为重写原型对象之后，之前创建的实例引用的依然是之前的原型对象，其与现有原型之间并无联系，而之后创建的实例[[Prototype]]指针引用的就是现有原型。</p>
<h3 id="u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898"><a href="#u539F_u578B_u5BF9_u8C61_u5B58_u5728_u95EE_u9898" class="headerlink" title="原型对象存在问题"></a>原型对象存在问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">3</span>;</span><br><span class="line">Animal.prototype.partner = [<span class="string">'one'</span>];</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one"] </span></span><br><span class="line">animal1.partner.push(<span class="string">'two'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal2.partner); <span class="comment">//输出["one", "two"] </span></span><br><span class="line"><span class="built_in">console</span>.log(animal1.partner === animal2.partner); <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure>
<p>可以看到原型中所有属性都被实例共享，特别是对于引用类型的属性，如上的partner属性。</p>
<h3 id="u9ED8_u8BA4_u539F_u578B"><a href="#u9ED8_u8BA4_u539F_u578B" class="headerlink" title="默认原型"></a>默认原型</h3><p>所有引用类型默认都继承自Object，所有构造函数默认原型都是Object的实例，默认原型都会包含一个内部指针，指向Object.prototype。</p>
<h3 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B_u7684_u5173_u7CFB" class="headerlink" title="构造函数，原型与实例的关系"></a>构造函数，原型与实例的关系</h3><p>每个构造函数都有一个原型对象，由prototype属性指向；原型对象包含一个指向构造函数的指针constructor；而实例都包含一个指向构造函数原型对象的内部指针[[Prototype]]。</p>
<h2 id="u539F_u578B_u94FE"><a href="#u539F_u578B_u94FE" class="headerlink" title="原型链"></a>原型链</h2><p>每一个构造函数都有一个原型对象，当我们让某一原型对象等于另一构造函数的实例，此时该原型对象就包含一个指针，该指针指向这一构造函数的原型对象，该指针指向的原型对象中包含一个指向这一构造函数的指针，同样我们可以令该指针指向的原型对象等于另一构造函数的实例，如此递进，则形成一条实例与原型的链条，即原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.childname = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.getChildName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.childname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getName()); <span class="comment">//输出parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getChildName());  <span class="comment">//输出child</span></span><br></pre></td></tr></table></figure>
<p>如上代码，child实例指向Child原型，Child原型等于Parent实例，即指向Parent原型。可见本质即是以一个新类型（构造函数）的实例重写原型对象，形成原型链。</p>
<h3 id="u539F_u578B_u94FE_u95EE_u9898"><a href="#u539F_u578B_u94FE_u95EE_u9898" class="headerlink" title="原型链问题"></a>原型链问题</h3><p>既然原型对象存在问题，那么原型链自然也继承了这个问题，即原型属性会被所有实例共享，对于原型属性的改变将影响所有实例，而在原型链中，由于某一原型对象等于另一构造函数的实例，实例受影响，也就导致其他原型对象也受影响。</p>
<p>原型与原型链是JavaScript实现继承的基础，下一篇详细介绍JavaScript之继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[在基于类的语言中，对象是类的实例，并且类可以从另一个类继承，如Java；JavaScript则是一门基于原型的语言，以原型链实现继承，其对象可以直接继承自另一对象，此篇详细阐述JavaScript之原型与原型链。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Prototype" scheme="http://blog.codingplayboy.com/tags/Prototype/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之解释与执行机制]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-compileRun/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-compileRun/</id>
    <published>2016-01-06T13:09:50.000Z</published>
    <updated>2016-01-06T13:19:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236"><a href="#JavaScript_u4E4B_u89E3_u91CA_u4E0E_u6267_u884C_u673A_u5236" class="headerlink" title="JavaScript之解释与执行机制"></a>JavaScript之解释与执行机制</h1><p>不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。</p>
<blockquote>
<p>解释型语言：程序不需要编译，程序在运行时才<strong>翻译</strong>成机器语言，每执行一次都要翻译一次。</p>
<p>编译型语言：程序在执行之前需要一个专门的<strong>编译</strong>过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果。</p>
</blockquote>
<p><em>JavaScript翻译过程又做解释过程。</em></p>
<h2 id="JavaScript_u89E3_u91CA_u4E0E_u6267_u884C"><a href="#JavaScript_u89E3_u91CA_u4E0E_u6267_u884C" class="headerlink" title="JavaScript解释与执行"></a>JavaScript解释与执行</h2><p>JavaScript按照代码块来进行解释和执行，代码块间相互独立，但变量和方法共享。</p>
<blockquote>
<p>JavaScript中的代码块是指由<code>&lt;script&gt;&lt;/script&gt;</code>标签分割的代码段。</p>
</blockquote>
<h3 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h3><p>JavaScript代码块在执行时先由解释器进行解释，主要过程是声明所有var变量（并未初始化赋值，当前值为undefined）、解析<strong>声明式</strong>函数语句，而且是先预定义变量再预定义函数。</p>
<blockquote>
<p>JavaScript中函数定义主要主要有两种：声明式与函数表达式。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u7801_u5206_u6790"><a href="#u4EE3_u7801_u5206_u6790" class="headerlink" title="代码分析"></a>代码分析</h3><ol>
<li><strong>试分析以下代码：</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">var a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>弹出undefined和ok。因为执行时先解释：1.定义var变量，并未初始化赋值，当前值为undefined。</p>
<ol>
<li><strong>请君细看</strong></li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert<span class="list">(<span class="keyword">a</span>)</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="quoted">'ok</span>')</span><span class="comment">;</span></span><br><span class="line">a = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>会发现报错了，因为a未定义，解释时定义var变量，并不会定义此处的a。</p>
<p>到这里我们又发现了一个值得关注的问题–定义变量的方式。</p>
<blockquote>
<p>JavaScript变量分两种：全局变量和局部变量。像a = 1;这种定义默认是创建全局变量，其实就相当于window.a = 1;而var a = 1;这种格式是定义一个当前作用域下的变量。解释时只会定义var格式的变量。</p>
</blockquote>
<p>3.<strong>函数相关</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"函数表达式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok1'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    a();  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123; <span class="comment">//声明式函数</span></span><br><span class="line">        alert(<span class="string">"声明式函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'ok2'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如何呢？运行上述代码你会发现弹出了“声明式函数”和“ok2”。<br>为什么呢，这里就涉及到前面所说的<strong>代码块之间是相互独立的</strong>，故前面的a()虽然报错了，阻塞了ok1弹出；但是第二段script代码并不受影响。</p>
<p>第一段代码缘何报错？因为代码执行时先解释声明式函数而不会解释函数表达式，此时只是定义了a变量，未初始化，其值为undefined,不是函数。</p>
<p>到此时对JavaScript的解释与执行机制、顺序也算有初步的认识了。</p>
]]></content>
    <summary type="html">
    <![CDATA[不同于其他的编译性语言如Java、C等，运行前需要将其编译为机器语言的文件，JavaScript在运行程序的时候才翻译，即JavaScript是一门解释性脚本语言。]]>
    
    </summary>
    
      <category term="Compile" scheme="http://blog.codingplayboy.com/tags/Compile/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript之面向对象]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/06/js-object/"/>
    <id>http://blog.codingplayboy.com/2016/01/06/js-object/</id>
    <published>2016-01-05T16:16:11.000Z</published>
    <updated>2016-01-06T13:12:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61"><a href="#JavaScript_u4E4B_u9762_u5411_u5BF9_u8C61" class="headerlink" title="JavaScript之面向对象"></a>JavaScript之面向对象</h1><p>传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。</p>
<h2 id="u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B"><a href="#u52A8_u6001_u7C7B_u578B_u4E0E_u9759_u6001_u7C7B_u578B" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>何谓动态，何谓静态？编程语言按数据类型大体分为两类：动态类型语言，静态类型语言。</p>
<blockquote>
<p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行时，待变量被赋值后，才会具有某种类型。</p>
</blockquote>
<p>典型的静态类型语言有Java, C#等，而在JavaScript中，当我们为某变量赋值时，并不需要判断其类型，其显然是一门典型的动态类型语言。</p>
<h2 id="JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE"><a href="#JavaScript_u5BF9_u8C61_u548C_u539F_u578B_u94FE" class="headerlink" title="JavaScript对象和原型链"></a>JavaScript对象和原型链</h2><h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>与对象最紧密相关当然是变量了<br>JavaScript的中有五种简单数据类型（也称基本数据类型）以及一种复杂数据类型。<br>简单数据类型包括数字, 字符串, 布尔值（true和false）, null, undefined值。<br>复杂数据类型即Object。<strong>JavaScript中除了简单数据类型值，其他所有值均为对象。</strong></p>
<h4 id="JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C"><a href="#JavaScript_u53D8_u91CF_u4E4B_u57FA_u672C_u7C7B_u578B_u503C_u4E0E_u5F15_u7528_u7C7B_u578B_u503C" class="headerlink" title="JavaScript变量之基本类型值与引用类型值"></a>JavaScript变量之基本类型值与引用类型值</h4><p>JavaScript变量可能包含两种不同数据类型的值：基本数据类型值和引用类型值。将一个值赋给变量时，解析器会判断这个值的类型。</p>
<blockquote>
<p>基本类型值指的是简单的数据段，是按值访问的，可以操作保存在变量中的实际值；而引用类型值指那些可能由多个值构成的对象，是引用类型的一个实例，是按引用访问的。</p>
</blockquote>
<ul>
<li><strong>基本类型</strong> 即包括如前所述的五种。</li>
<li><strong>引用类型</strong> 一种数据结构，用以描述对象的属性和方法。</li>
</ul>
<p><em>注：引用类型值和引用类型不同。</em></p>
<p>JavaScript引用类型主要包括Object，Array，Date，RegExp，Function以及为了操作基本类型值提供的三个特殊引用类型：Boolean，Number和String。<strong>可以说，JavaScript中对象即是某种引用类型的实例，我们使用的大多数引用类型值又都是Object类型的实例。</strong></p>
<h3 id="JavaScript_u521B_u5EFA_u5BF9_u8C61"><a href="#JavaScript_u521B_u5EFA_u5BF9_u8C61" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h3><p>不同于许多传统面向对象语言使用基于类的对象，JavaScript使用基于原型的对象。</p>
<ul>
<li><strong>对象字面量</strong> 一个对象字面量就是在一对花括号中的零或多个名值对。</li>
<li><strong>Object构造函数</strong> 调用Object构造函数，可使用new Object()形式创建对象。<em>Object.create()方式创建对象亦很常见。</em></li>
</ul>
<h3 id="JavaScript_u7EE7_u627F"><a href="#JavaScript_u7EE7_u627F" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h3><p>继承（Object Orient）向来是面向对象语言最突出特征之一，如Java等传统OO语言都支持基于类的继承，而JavaScript中是没有类的概念，其主要依靠原型链实现继承。</p>
<blockquote>
<p>基于原型链的委托机制就是原型继承的本质，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<h4 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h4><p>对象的原型，就JavaScript真正实现而言，其实对象并无原型，而是对象的构造器（构造函数）与原型。所谓‘对象把请求委托给自己的原型’即是把请求委托给其构造器原型。JavaScript对象的__proto__属性默认即指向其构造器原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B"><a href="#u6784_u9020_u51FD_u6570_uFF0C_u539F_u578B_u4E0E_u5B9E_u4F8B" class="headerlink" title="构造函数，原型与实例"></a>构造函数，原型与实例</h4><p><strong>每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而构造函数的实例都包含一个指向原型对象的内部指针。JavaScript中所有对象都默认继承自根对象Object。</strong></p>
<p>给一个构造函数的原型对象赋值为另一个类型的实例，此时原型对象即包含指向另一原型对象的指针，而另一个原型对象中也包含指向其相应构造函数的指针，如此便构成了原型与实例的关系链，也即原型链。依此可实现不同对象间的属性和方法的继承。</p>
<ul>
<li><strong>默认原型</strong> 所有引用类型默认都继承了Object，所有函数的默认原型都是Object实例，而如前所述：构造函数的实例都包含一个指向原型对象的内部指针，因此默认原型都包含一个指向Object.prototype（即Object原型）的内部指针。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="string">'Animal'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getAnimalProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">this</span>.dogproperty = <span class="string">'Dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承自Animal</span></span><br><span class="line">Dog.prottotype.getDogProperty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>. dogproperty; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">alert(dog.getDogProperty);</span><br><span class="line">alert(dog.getAnimalProperty);</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>对象的根对象</strong> JavaScript对象都源于（继承自）根对象Object。</li>
<li><strong>对象源自克隆</strong> 定义对象，不是通过实例化类，而是把另一对象作为原型并克隆之。</li>
<li><strong>对象记忆性</strong> 请求可以在原型链中依此向后传递，每个对象都会记住自己的原型，详细请回顾上文关于对象原型之说的__proto__属性。</li>
<li><strong>对象请求传递性</strong> 若当前对象无法响应当前请求，便将其委托给其构造器原型。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[传统面向对象语言有一个通用标志，即类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而JavaScript中没有类的概念，它的对象与传统面向对象语言有所不同。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/tags/JavaScript/"/>
    
      <category term="Object Oriented" scheme="http://blog.codingplayboy.com/tags/Object-Oriented/"/>
    
      <category term="JavaScript" scheme="http://blog.codingplayboy.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <link href="http://blog.codingplayboy.com/2016/01/04/hello-world/"/>
    <id>http://blog.codingplayboy.com/2016/01/04/hello-world/</id>
    <published>2016-01-03T16:16:11.000Z</published>
    <updated>2016-01-06T13:32:25.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on GitHub.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://blog.codingplayboy.com/categories/Hexo/"/>
    
  </entry>
  
</feed>
